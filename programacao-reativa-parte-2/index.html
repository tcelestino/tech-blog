<!doctype html>
<html lang="pt-br">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Continuando a série sobre Programação Reativa, agora com um pouco de código!">
	<meta name="google-site-verification" content="NqCILBTY8B8P-r_KF8BSZKH9kUQgQOEbXJvEMaB33vw">
	<meta name="google-site-verification" content="cKh-stJM3_ENNfMjaBIIyYiDgMXZFpRkoH8eQTcPwhM" />
	<meta name="theme-color" content="#FDC24F">
	<meta name="keywords" content="Elo7,tecnologia,post,desenvolvimento,blog,java,programacao-reativa">
	<meta name="language" content="pt-br">
	<meta name="title" content="Elo7 Tech - Programação Reativa - Parte 2">
	<meta name="apple-mobile-web-app-title" content="Elo7 Tech - Programação Reativa - Parte 2">
	<meta name="mobile-web-app-capable" content="yes">

	<meta property="fb:app_id" content="644444999041914">
	<meta property="fb:admins" content="100003324447975">

	<meta property="og:site_name" content="Elo7 Tech">
	<meta property="og:image" content="https://engenharia.elo7.com.br/images/ico/elo7.png">
	<meta property="og:type" content="website">
	<meta property="og:title" content="Elo7 Tech - Programação Reativa - Parte 2">
	<meta property="og:url" content="https://engenharia.elo7.com.br/programacao-reativa-parte-2/">
	<meta property="og:description" content="Continuando a série sobre Programação Reativa, agora com um pouco de código!">

	<meta name="twitter:widgets:csp" content="on">
	<meta name="twitter:card" content="summary_large_image">

	<meta property="twitter:title" content="Elo7 Tech - Programação Reativa - Parte 2">
	<meta property="twitter:domain" content="https://engenharia.elo7.com.br">
	<meta property="twitter:url" content="https://engenharia.elo7.com.br/programacao-reativa-parte-2/">
	<meta property="twitter:description" content="Continuando a série sobre Programação Reativa, agora com um pouco de código!">
	<meta property="twitter:image" content="https://engenharia.elo7.com.br/images/ico/elo7.png">

	<link rel="canonical" href="https://engenharia.elo7.com.br/programacao-reativa-parte-2/">
	
		<link rel='amphtml' href='https://engenharia.elo7.com.br/amp/programacao-reativa-parte-2/' />
	

	<title>Elo7 Tech - Programação Reativa - Parte 2</title>
	<link rel="stylesheet" href="/reset.css">
	<link rel="stylesheet" href="/main.css">
	<link rel="stylesheet" href="/posts.css">
	<link rel="stylesheet" href="/post.css">
	<link rel="icon" href="/images/favicon/favicon-16.png" sizes="16x16">
	<link rel="icon" href="/images/favicon/favicon-32.png" sizes="32x32">
	<link rel="icon" href="/images/favicon/favicon-48.png" sizes="48x48">
	<link rel="icon" href="/images/favicon/favicon-64.png" sizes="64x64">
	<link rel="icon" href="/images/favicon/favicon-96.png" sizes="96x96">
	<link rel="icon" href="/images/favicon/favicon-128.png" sizes="128x128">
	<link rel="icon" href="/images/favicon/favicon-160.png" sizes="160x160">
	<link rel="icon" href="/images/favicon/favicon-192.png" sizes="192x192">
	<link rel="apple-touch-icon-precomposed" sizes="180x180" href="/images/favicon/favicon-180.png">
	<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/images/favicon/favicon-152.png">
	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/favicon/favicon-144.png">
	<link rel="apple-touch-icon-precomposed" sizes="120x120" href="/images/favicon/favicon-120.png">
	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/images/favicon/favicon-114.png">
	<link rel="apple-touch-icon-precomposed" sizes="76x76" href="/images/favicon/favicon-76.png">
	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/favicon/favicon-72.png">
	<link rel="apple-touch-icon-precomposed" sizes="60x60" href="/images/favicon/favicon-60.png">
	<link rel="apple-touch-icon-precomposed" sizes="57x57" href="/images/favicon/favicon-57.png">
	<link rel="apple-touch-icon-precomposed" href="/images/favicon/favicon-precomposed.png">
	<script>window.addEventListener("error", window.__e=function f(e){f.q=f.q||[];f.q.push(e)});</script>
	<script src="/js/vendor/async-define.js"></script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" data-env="production" data-ga-code="UA-3692628-29">
	<header class="left-pane">
		<div class="logo-container">
			<a rel="home" itemprop="url" href="/" class="logo">Tech Blog Elo7</a>
		</div>
		<div itemscope itemtype="http://schema.org/SiteNavigationElement" class="navigation">
			<input id="categories-switch" type="checkbox" class="categories-switch">
			<label for="categories-switch" class="selectable">
				<h2 class="nav-title">Categorias</h2>
			</label>
			<nav aria-label="Navegue pelas categorias do nosso blog" class="nav-list nav-category">
				
					<a itemprop="url" href="/back-end/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Back-end</span>
					</a>
				
					<a itemprop="url" href="/cultura/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Cultura</span>
					</a>
				
					<a itemprop="url" href="/data-science/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Data Science</span>
					</a>
				
					<a itemprop="url" href="/design/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Design</span>
					</a>
				
					<a itemprop="url" href="/devops/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Devops</span>
					</a>
				
					<a itemprop="url" href="/eventos/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Eventos</span>
					</a>
				
					<a itemprop="url" href="/front-end/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Front-end</span>
					</a>
				
					<a itemprop="url" href="/mobile/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Mobile</span>
					</a>
				
					<a itemprop="url" href="/vagas/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Vagas</span>
					</a>
				
			</nav>
		</div>
		<div class="navigation">
			<input id="more-switch" type="checkbox" class="more-switch">
			<label for="more-switch" class="selectable">
				<h2 class="nav-title">Veja também</h2>
			</label>
			<nav class="nav-list nav-more" aria-label="Navegue pelos links relacionados ao Elo7">
				<a itemscope itemtype="http://schema.org/SiteNavigationElement" itemprop="url" href="http://carreira.elo7.com.br/engenharia/" target="_blank">
					<span itemprop="name">A engenharia</span>
				</a>
				<a itemscope itemtype="http://schema.org/SiteNavigationElement" itemprop="url" href="http://carreira.elo7.com.br/" target="_blank">
					<span itemprop="name">Carreiras</span>
				</a>
				<a itemscope itemtype="http://schema.org/SiteNavigationElement" itemprop="url" href="http://eventos.elo7.com.br/" target="_blank">
					<span itemprop="name">Nossos eventos</span>
				</a>
				<a itemscope itemtype="http://schema.org/SiteNavigationElement" itemprop="url" href="http://elo7.com.br/" target="_blank">
					<span itemprop="name">Elo7</span>
				</a>
			</nav>
		</div>
		<div class='social'>
			<a title="Github do Elo7" rel="external" itemprop="url" href="https://github.com/elo7" target="_blank" class="github">Github do Elo7</a>
			<a title="Twitter do Elo7" rel="external" itemprop="url" href="https://twitter.com/elo7tech" target="_blank" class="twitter">Twitter do Elo7</a>
			<a title='RSS do Elo7' rel="external" itemprop="url" href="https://engenharia.elo7.com.br/rss.xml" target="_blank" class="rss">RSS do Elo7</a>
			<a title='Newsletter do Elo7' rel="external" itemprop="url" href="http://eepurl.com/cVUwvH" target="_blank" class="email">Newsletter do Elo7</a>
		</div>
	</header>
	<main aria-label="Main content" itemscope itemtype="http://schema.org/Blog">
		<article itemprop='blogPost' itemscope itemtype='http://schema.org/BlogPosting' class='post-content'>
	<h1 itemprop='name' class='title'>Programação Reativa - Parte 2</h1>
	<div class='post-meta'>
		<p class='date'>
			Publicado em: <time datetime='21/05/2018' itemprop='datePublished'>21/05/2018</time>
			<meta itemprop='dateModified' content='21/05/2018'>
		</p>

		<article>
			
				<a data-author='ljtfreitas' itemprop='author' itemscope itemtype='http://schema.org/Person' rel='author' href='/ljtfreitas/' class='author'>
					<meta itemprop='url' content='/ljtfreitas'>
					<img class='hide avatar' width='50px' height='50px' itemprop='image'>
					<p itemprop='name' class='publisher' data-author='ljtfreitas'>@ljtfreitas</p>
				</a>
			

			<meta itemprop='worksFor' content='Elo7 Serviços de Informática SA'>
		</article>
	</div>
	<div itemprop='articleBody'>
		<p>No <a href="/programacao-reativa">post anterior</a>, vimos os fundamentos da programação reativa, incluindo o funcionamento básico sobre os quais os frameworks da família <a href="http://reactivex.io/">ReactiveX</a> são implementados. Nessa segunda fase da nossa &quot;jornada reativa&quot;, começaremos a estudar os principais recursos e funcionalidades do <a href="https://github.com/ReactiveX/RxJava">RxJava</a>, e então estaremos mais preparados para aplicar esses conceitos - não apenas em &quot;programas&quot; mas em &quot;sistemas&quot;, os chamados <strong>sistemas reativos</strong>.</p>
<p>Os exemplos deste post estão implementados com o RxJava (a versão 2, compatível com o <a href="http://www.reactive-streams.org/">Reactive Streams</a>, que tem <a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0">algumas diferenças</a> para a versão anterior). Porém, os mesmos fundamentos são aplicáveis em qualquer outro framework da família Rx, ou mesmo outros frameworks reativos como o <a href="https://projectreactor.io/">Reactor</a>.</p>
<blockquote>
<p><em>“É fazendo que se aprende o que se deve aprender a fazer. (Aristóteles)”</em></p>
</blockquote>
<h2>Observables</h2>
<p>Conforme dito (superficialmente) no <a href="/programacao-reativa">post anterior</a>, a principal classe do RxJava é o <a href="http://reactivex.io/documentation/observable.html">Observable</a>, que representa um fluxo de dados (contínuos ou discretos, finitos ou infinitos). Essa classe contêm todos os operadores reativos disponíveis no RxJava. Para nossos propósitos, podemos criar uma instância a partir de uma lista de valores fixos, e nos <em>subscrevermos</em> ao <code>Observable</code> criado:</p>
<pre class="highlight"><code class="hljs java">Observable&lt;String&gt; observable = Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>);

observable.subscribe(System.out::println);

<span class="hljs-comment">/*
output:

one
two
three
*/</span>
</code></pre>
<p>Nesse código, nós estamos executando uma ação no evento <em>onNext</em>. Recapitulação rápida: <em>onNext</em> é o evento que representa a emissão de um valor pelo Observable. Os outros dois eventos possíveis em um fluxo reativo são o <em>onError</em> e o <em>onCompleted</em>. Se quiséssemos executar algum código quando esses dois eventos ocorressem, poderíamos usar as sobrecargas do método <em>subscribe</em>:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-comment">//onError</span>

Observable&lt;String&gt; observable = Observable.error(<span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"ooops..."</span>)); <span class="hljs-comment">// esse Observable irá emitir apenas um erro</span>

observable.subscribe(System.out::println, Throwable::printStackTrace); <span class="hljs-comment">//o segundo parâmetro é a ação que deverá ser realizada em caso de erro (um Consumer que recebe um Throwable)</span>

<span class="hljs-comment">/*
output:

java.lang.RuntimeException: ooops...
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java"><span class="hljs-comment">//onCompleted</span>

Observable&lt;String&gt; observable = Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>);

observable.subscribe(System.out::println, Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"Completed..."</span>)); <span class="hljs-comment">//o terceiro parâmetro é a ação que deverá ser realizada quando o Observable for completado (um objeto do tipo Action que não recebe parâmetros)</span>

<span class="hljs-comment">/*
output:

one
two
three
Completed...
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java"><span class="hljs-comment">//outra maneira é se subscrever usando um objeto do tipo Observer; desse modo você pode implementar as acões de cada evento em um único objeto</span>

Observable&lt;String&gt; observable = Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>);

observable.subscribe(<span class="hljs-keyword">new</span> Observer&lt;String&gt;() {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable d)</span> </span>{
        System.out.println(<span class="hljs-string">"Alguém se subscreveu..."</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String t)</span> </span>{
        System.out.println(t);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>{
        e.printStackTrace();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Completed..."</span>);
    }
});

<span class="hljs-comment">/*
output:

Alguém se subscreveu...
one
two
three
Completed...
*/</span>
</code></pre>
<p>O <code>Observable</code> possui muitos métodos de fábrica que podem ser utilizados para criação. O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#just-T-">just</a> utilizado nos exemplos acima cria um Observable a partir de uma sequência fixa de valores; podemos utilizar também um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#range-int-int-">intervalo de valores</a>, um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#timer-long-java.util.concurrent.TimeUnit-">intervalo de tempo</a>, um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromCallable-java.util.concurrent.Callable-">Callable</a>, um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromFuture-java.util.concurrent.Future-">Future</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromPublisher-org.reactivestreams.Publisher-">outro Observable</a>...veremos todos esses métodos em detalhes no decorrer do post.</p>
<h2>Completable, Single, Maybe</h2>
<p>Na versão 2 do RxJava, existem algumas especializações interessantes sobre o comportamento de um fluxo reativo. Eventualmente, queremos nos sobrescrever a um objeto observável com uma semântica diferente de um <code>Observable</code> convencional; às vezes esse objeto não irá emitir valores (ou emitirá um erro ou apenas completará), ou emitirá apenas um valor, ou <em>talvez</em> emita apenas um valor (ou nenhum). Existem alguns objetos específicos para essas situações.</p>
<h3>Completable</h3>
<p><a href="http://reactivex.io/RxJava/javadoc/">Completable</a> representa um computação que <strong>não devolve valores</strong>, podendo gerar um erro ou ser concluída sem erros. Um <code>Completable</code>, então, nunca irá emitir o evento <em>onNext</em>; apenas <em>onCompleted</em> ou <em>onError</em>.</p>
<pre class="highlight"><code class="hljs java">Completable completable = Completable.complete();

completable.subscribe(() -&gt; System.out.println(<span class="hljs-string">"Completed..."</span>));

<span class="hljs-comment">/*
output:

Completed...
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java">Completable completable = Completable.error(<span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"oops..."</span>));

completable.subscribe(() -&gt; System.out.println(<span class="hljs-string">"Completed..."</span>), Throwable::printStackTrace); <span class="hljs-comment">//o segundo parâmetro é a ação que deverá ser realizada em caso de erro (um Consumer que recebe um Throwable)</span>

<span class="hljs-comment">/*
output:

java.lang.RuntimeException: oops...
*/</span>
</code></pre>
<p>E para o que poderia servir isso? Talvez para algo assim:</p>
<pre class="highlight"><code class="hljs java">Completable completable = Completable.fromAction(() -&gt; {
    <span class="hljs-comment">/* aqui você poderia executar alguma ação como invocar uma API externa, persistir alguma informação, etc.
       ou qualquer outra tarefa onde você não precisa de algum valor de retorno,
       mas precisa reagir caso ocorra algum erro ou quando essa ação seja concluída
    */</span>
});

completable.subscribe(() -&gt; System.out.println(<span class="hljs-string">"Ok...a ação terminou sem erros."</span>), Throwable::printStackTrace);
</code></pre>
<h3>Single</h3>
<p><a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Single.html">Single</a> é um objeto que pode emitir <strong>apenas um valor</strong>, ou um erro. Um <code>Single</code> não emite o evento <em>onCompleted</em>, pois o fato de emitir o <em>onNext</em> apenas uma vez indica de maneira implícita que o <code>Single</code> foi &quot;completado&quot;.</p>
<pre class="highlight"><code class="hljs java">Single&lt;String&gt; single = Single.just(<span class="hljs-string">"one"</span>);

single.subscribe(System.out::println);

<span class="hljs-comment">/*
output:

one
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java">Single&lt;String&gt; single = Single.error(<span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"oops..."</span>));

single.subscribe(System.out::println, Throwable::printStackTrace);
<span class="hljs-comment">/*
output:

java.lang.RuntimeException: oops...
*/</span>
</code></pre>
<h3>Maybe</h3>
<p><a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Maybe.html">Maybe</a> é um objeto que <strong>pode</strong> emitir um valor, mas que talvez não emita nenhum. Caso esse valor exista, esse objeto emitirá um evento diferente chamado <em>onSuccess</em>; se não, poderá emitir os eventos <em>onError</em> ou <em>onCompleted</em>. Esses eventos são <strong>excludentes</strong>; se o <em>onSucess</em> for disparado, o <code>Maybe</code> será implicitamente completado (o <em>onError</em> tem a mesma semântica); se o <code>Maybe</code> não emitir nenhum valor apenas o <em>onCompleted</em> será disparado.</p>
<pre class="highlight"><code class="hljs java">Maybe&lt;String&gt; maybe = Maybe.just(<span class="hljs-string">"any value"</span>);

maybe.subscribe(System.out::println); <span class="hljs-comment">//onSuccess</span>

<span class="hljs-comment">/*
output:

any value
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java">Maybe&lt;String&gt; maybe = Maybe.error(<span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"oops..."</span>));

maybe.subscribe(System.out::println, Throwable::printStackTrace);

<span class="hljs-comment">/*
output:

java.lang.RuntimeException: oops...
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java">Maybe&lt;String&gt; maybe = Maybe.empty();

maybe.subscribe(System.out::println, Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"Completed..."</span>));

<span class="hljs-comment">/*
output:

Completed...
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java"><span class="hljs-comment">/* Esse exemplo demonstra bem a diferença entre um Maybe e um Observable.
   Aqui, estamos criando o Maybe a partir de uma computação que devolve null.
   Nessa situação, o Maybe irá emitir o evento onCompleted, pois não há valor a ser emitido para o onSuccess.
   Já um Observable nunca emite valores nulos (o código abaixo lançaria uma exceção, se fosse um Observable).
*/</span>

Maybe&lt;String&gt; maybe = Maybe.fromCallable(() -&gt; <span class="hljs-keyword">null</span>);

maybe.subscribe(System.out::println, Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"Completed..."</span>));

<span class="hljs-comment">/*
output:

Completed...
*/</span>
</code></pre>
<h2>Ciclo de vida de um Subscriber</h2>
<p>Nos exemplos acima, nosso código se subscreve às fontes de eventos reativos (<code>Observable</code>, <code>Completable</code>, etc) e reage conforme as coisas acontecem. Como vimos no post anterior, o ato de vincular um <em>Subscriber</em> a um fluxo de dados é chamado de <strong>subscription</strong>. Na versão 1.x, o RxJava possuía um objeto chamado <a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Subscription.html">Subscription</a> para representar esse conceito, e esse objeto era responsável pelo ciclo de vida de uma subscrição. Na versão 2.x, essa classe foi renomeada para <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/disposables/Disposable.html">Disposable</a>.</p>
<p>Eventualmente, um comportamento que podemos desejar é <strong>cancelar</strong> uma subscrição; podemos fazer isso facilmente. No exemplo abaixo, um <code>Observable</code> é criado a partir do método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#interval-long-java.util.concurrent.TimeUnit-">interval</a>; esse método cria um <code>Observable</code> que emite um valor do tipo <code>Long</code> a cada intervalo de tempo:</p>
<pre class="highlight"><code class="hljs java">Observable&lt;Long&gt; observable = Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);

observable.subscribe(System.out::println);

Thread.sleep(<span class="hljs-number">5000</span>);

<span class="hljs-comment">/*
output:

0
1
2
3
4
*/</span>
</code></pre>
<p>O método <code>subscribe</code> devolve um <code>Disposable</code>, que podemos utilizar para cancelar a subscrição:</p>
<pre class="highlight"><code class="hljs java">Observable&lt;Long&gt; observable = Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);

Disposable subscription = observable.subscribe(System.out::println);

Thread.sleep(<span class="hljs-number">2000</span>);

subscription.dispose(); <span class="hljs-comment">//o método dispose cancela a subscrição; os eventos emitidos a partir daqui já não serão capturados por esse objeto</span>

Thread.sleep(<span class="hljs-number">3000</span>);

<span class="hljs-comment">/*
output:

0
1
*/</span>
</code></pre>
<h2>Posso ter mais de um subscriber?</h2>
<p>Sim! Você pode vincular ao <code>Observable</code> quantos <em>subscribers</em> desejar (o mesmo se aplica ao <code>Completable</code>, <code>Single</code> e <code>Maybe</code>). Isso pode trazer uma questão cuja resposta pode não ser tão óbvia: digamos que criamos um <code>Observable</code> a partir de uma lista de valores finitos (como os exemplos acima), nos subscrevemos e recebemos todos os eventos <em>onNext</em> e depois o <em>onCompleted</em>, que é um evento <strong>terminal</strong>; o que acontece se fizemos outra subscrição após esse evento?</p>
<pre class="highlight"><code class="hljs java">Observable&lt;String&gt; observable = Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>);

observable.subscribe(System.out::println, Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"Completed..."</span>));

<span class="hljs-comment">/*
output:

one
two
three
Completed...
*/</span>
</code></pre>
<p>Se adicionarmos um novo <em>subscriber</em>:</p>
<pre class="highlight"><code class="hljs java">Observable&lt;String&gt; observable = Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>);

observable.subscribe(System.out::println, Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"Completed..."</span>));

observable.subscribe(v -&gt; System.out.println(<span class="hljs-string">"Second subscriber: "</span> + v));

<span class="hljs-comment">/*
output:

one
two
three
Completed...
Second subscriber: one
Second subscriber: two
Second subscriber: three
*/</span>
</code></pre>
<p>A sequência de eventos foi re-executada quando o segundo <em>subscription</em> foi realizado. Com efeito, mesmo em relação ao primeiro <em>subscriber</em>, os eventos só foram enviados <strong>após</strong> a subscrição ter sido realizada, o que nos leva a concluir: até você se subscrever, <strong>nada acontece</strong>.</p>
<p>Mas será que sempre vamos desejar esse comportamento? E se nosso Observable fosse gerado a partir de um fluxo assíncrono e potencialmente infinito (digamos, um <em>stream</em> do Twitter), e quiséssemos que novos <em>subscribers</em> ouvissem os eventos gerados <strong>a partir do momento em que eles se subscreveram</strong>, seria possível?</p>
<h3>Observables &quot;frios&quot; e &quot;quentes&quot;</h3>
<p>Nos frameworks Rx, existem dois &quot;sabores&quot; de Observables, chamados <strong>cold</strong> (frios) e <strong>hot</strong> (quentes). O comportamento que vimos acima é de um <code>Observable</code> frio; a sequência de eventos é executada <strong>apenas quando e se o Observable tenha algum subscriber associado</strong>, e o fluxo de eventos é executado para cada subscrição realizada. O exemplo abaixo (novamente usando o método <code>interval</code>) demonstra bem esse funcionamento:</p>
<pre class="highlight"><code class="hljs java">Observable&lt;Long&gt; observable = Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);

observable.subscribe(v -&gt; System.out.println(<span class="hljs-string">"First subscriber: "</span> + v));

Thread.sleep(<span class="hljs-number">2000</span>);

observable.subscribe(v -&gt; System.out.println(<span class="hljs-string">"Second subscriber: "</span> + v));

Thread.sleep(<span class="hljs-number">2000</span>);

<span class="hljs-comment">/*
output:

First subscriber: 0
First subscriber: 1
First subscriber: 2
Second subscriber: 0
First subscriber: 3
Second subscriber: 1
...
*/</span>
</code></pre>
<p>Os dois <em>subscribers</em> não recebem os mesmos valores ao mesmo tempo, embora ambos estejam vinculados ao mesmo <code>Observable</code>. Eles recebem <strong>a mesma sequência de eventos</strong>, com a diferença que o &quot;início&quot; dos eventos para cada um se dará a partir do momento da subscrição.</p>
<p>Todo <code>Observable</code> criado a partir do método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#create-io.reactivex.ObservableOnSubscribe-">create</a> é um &quot;cold observable&quot;, incluindo todos os métodos auxiliares como <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#just-T-">just</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#range-int-int-">range</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#timer-long-java.util.concurrent.TimeUnit-">timer</a>, <code>from*</code>(<a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromArray-T...-">fromArray</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromCallable-java.util.concurrent.Callable-">fromCallable</a>, etc) e o próprio <code>interval</code> do exemplo acima.</p>
<p>Um &quot;hot observable&quot; tem um comportamento diferente; ele emite eventos <strong>independente de haver algum subscriber associado</strong>. É possível converter um &quot;cold observable&quot; em &quot;hot observable&quot; usando o método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#publish--">publish</a>, que devolve um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/observables/ConnectableObservable.html">ConnectableObservable</a>, um tipo especial de <code>Observable</code> que passa a emitir sequências após a invocação do método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/observables/ConnectableObservable.html#connect--">connect</a>, havendo <em>subscribers</em> ou não. O código a seguir demonstra essa lógica:</p>
<pre class="highlight"><code class="hljs java">Observable&lt;Long&gt; observable = Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS); <span class="hljs-comment">//emite um valor a cada segundo: 0, 1, 2...</span>

ConnectableObservable&lt;Long&gt; hot = observable.publish(); <span class="hljs-comment">//o método publish devolve o ConnectableObservable</span>
hot.connect(); <span class="hljs-comment">//aqui a sequência de eventos será iniciada</span>

Thread.sleep(<span class="hljs-number">3000</span>); <span class="hljs-comment">//aguarda três segundos; nesse intervalo o Observable já terá emitido os valores 0, 1, e 2</span>

hot.subscribe(System.out::println); <span class="hljs-comment">//esse subscriber será notificado a partir do valor 3 da sequência</span>

Thread.sleep(<span class="hljs-number">3000</span>); <span class="hljs-comment">//aguarda por mais três segundos...</span>

<span class="hljs-comment">/*
output:

3
4
5
*/</span>
</code></pre>
<p>O método <code>connect</code> também devolve um <code>Disposable</code>, que poderia ser usado eventualmente para cancelar a emissão de eventos.</p>
<h2>Subjects</h2>
<p>Um objeto reativo muito interessante é o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/Subject.html">Subject</a>. Essa classe implementa a interface <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observer.html">Observer</a>, portanto pode <strong>ouvir</strong> eventos; também extende <code>Observable</code>, portanto, pode <strong>enviar</strong> eventos (ou reemitir).</p>
<p>Um <code>Subject</code> é ideal como &quot;porta de entrada&quot; para o mundo Rx, pois permite que você &quot;empurre&quot; valores para um <em>pipeline</em> reativo mesmo que tais valores sejam gerados fora do RxJava (lembre-se que o conceito de dados &quot;empurrados&quot; (push) é fundamental para a programação reativa).</p>
<pre class="highlight"><code class="hljs java">Observable&lt;String&gt; observable = Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>);

PublishSubject&lt;String&gt; subject = PublishSubject.create(); <span class="hljs-comment">//spoiler :)...mais informações daqui a pouco!</span>
subject.subscribe(System.out::println); <span class="hljs-comment">//podemos nos subscrever ao Subject</span>

observable.subscribe(subject); <span class="hljs-comment">//podemos usar o Subject para nos subscrevermos a outros Observables</span>

<span class="hljs-comment">/*
output:

one
two
three
*/</span>
</code></pre>
<p>No RxJava, o <code>Subject</code> tem várias implementações diferentes. Vamos analisar cada uma delas.</p>
<h3>PublishSubject</h3>
<p>Um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/PublishSubject.html">PublishSubject</a> emite eventos para o observador apenas a partir do instante em que a subscrição é realizada.</p>
<pre class="highlight"><code class="hljs java">PublishSubject&lt;String&gt; subject = PublishSubject.create();

<span class="hljs-comment">// o primeiro subscriber</span>
subject.subscribe(v -&gt; System.out.println(<span class="hljs-string">"First subscriber: "</span> + v));

<span class="hljs-comment">// emite dois eventos</span>
subject.onNext(<span class="hljs-string">"one"</span>);
subject.onNext(<span class="hljs-string">"two"</span>);

<span class="hljs-comment">// o segundo subscriber</span>
subject.subscribe(v -&gt; System.out.println(<span class="hljs-string">"Second subscriber: "</span> + v));

<span class="hljs-comment">//emite outro evento</span>
subject.onNext(<span class="hljs-string">"three"</span>);

<span class="hljs-comment">/*
output:

First subscriber: one
First subscriber: two
First subscriber: three
Second subscriber: three
*/</span>
</code></pre>
<p>Se ocorrer um evento terminal (<em>onCompleted</em> ou <em>onError</em>) os <em>subscribers</em> posteriores receberão apenas este evento:</p>
<pre class="highlight"><code class="hljs java">PublishSubject&lt;String&gt; subject = PublishSubject.create();

subject.subscribe(v -&gt; System.out.println(<span class="hljs-string">"First subscriber: "</span> + v), Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"OnComplete to first subscriber"</span>));

subject.onNext(<span class="hljs-string">"one"</span>);
subject.onNext(<span class="hljs-string">"two"</span>);

<span class="hljs-comment">// emite o evento onCompleted</span>
subject.onComplete();

subject.subscribe(v -&gt; System.out.println(<span class="hljs-string">"Second subscriber: "</span> + v), Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"OnComplete to second subscriber"</span>));

<span class="hljs-comment">/*
output:

First subscriber: one
First subscriber: two
OnComplete to first subscriber
OnComplete to second subscriber
*/</span>
</code></pre>
<h3>ReplaySubject</h3>
<p>O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/ReplaySubject.html">ReplaySubject</a> emite todos os valores para todos os <em>subscribers</em>, independente do momento em que a subscrição foi feita.</p>
<pre class="highlight"><code class="hljs java">ReplaySubject&lt;String&gt; subject = ReplaySubject.create();

subject.onNext(<span class="hljs-string">"one"</span>);
subject.onNext(<span class="hljs-string">"two"</span>);
subject.onNext(<span class="hljs-string">"three"</span>);
subject.onComplete();

subject.subscribe(v -&gt; System.out.println(<span class="hljs-string">"First subscriber: "</span> + v), Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"OnComplete to first subscriber"</span>));
subject.subscribe(v -&gt; System.out.println(<span class="hljs-string">"Second subscriber: "</span> + v), Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"OnComplete to second subscriber"</span>));

<span class="hljs-comment">/*
output:

First subscriber: one
First subscriber: two
First subscriber: three
OnComplete to first subscriber
Second subscriber: one
Second subscriber: two
Second subscriber: three
OnComplete to second subscriber
*/</span>
</code></pre>
<p>Armazenar todos os valores indefinidamente pode não ser o ideal. O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/ReplaySubject.html#createWithSize-int-">createWithSize</a> permite estabelecer um limite para o <em>buffer</em>:</p>
<pre class="highlight"><code class="hljs java">ReplaySubject&lt;String&gt; subject = ReplaySubject.createWithSize(<span class="hljs-number">2</span>);

subject.onNext(<span class="hljs-string">"one"</span>);
subject.onNext(<span class="hljs-string">"two"</span>);
subject.onNext(<span class="hljs-string">"three"</span>);
subject.onComplete();

subject.subscribe(v -&gt; System.out.println(<span class="hljs-string">"First subscriber: "</span> + v), Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"OnComplete to first subscriber"</span>));
subject.subscribe(v -&gt; System.out.println(<span class="hljs-string">"Second subscriber: "</span> + v), Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"OnComplete to second subscriber"</span>));

<span class="hljs-comment">/*
output:

First subscriber: two
First subscriber: three
OnComplete to first subscriber
Second subscriber: two
Second subscriber: three
OnComplete to second subscriber
*/</span>
</code></pre>
<p>Também é possível estabeler um limite de armazenamento baseado no tempo decorrido, com o método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/ReplaySubject.html#createWithTime-long-java.util.concurrent.TimeUnit-io.reactivex.Scheduler-">createWithTime</a>. Além dos parâmetros de tempo, esse método recebe um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Scheduler.html">Scheduler</a>; para evitar <em>spoilers</em>, não entrarei em detalhes agora desse importantíssimo objeto mas falaremos dele em detalhes no próximo post :).</p>
<p>O <code>Observable</code> tem um método chamado <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#replay--">replay</a>, que tem um comportamento equivalente.</p>
<pre class="highlight"><code class="hljs java">Observable&lt;String&gt; observable = Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>);

ConnectableObservable&lt;String&gt; hot = observable.replay();
hot.connect();

hot.subscribe(v -&gt; System.out.println(<span class="hljs-string">"First subscriber: "</span> + v), Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"OnComplete to first subscriber"</span>));
hot.subscribe(v -&gt; System.out.println(<span class="hljs-string">"Second subscriber: "</span> + v), Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"OnComplete to second subscriber"</span>));

<span class="hljs-comment">/*
output:

First subscriber: one
First subscriber: two
First subscriber: three
OnComplete to first subscriber
Second subscriber: one
Second subscriber: two
Second subscriber: three
OnComplete to second subscriber
*/</span>
</code></pre>
<p>O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#cache--">cache</a> também tem um comportamento semelhante, pois armazena todos os valores emitidos, mas não permite o gerenciamento do ciclo de vida das subscrições.</p>
<pre class="highlight"><code class="hljs java">Observable&lt;String&gt; observable = Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>);

<span class="hljs-comment">// o método cache não devolve um ConnectableObservable, ao contrário do método replay;</span>
<span class="hljs-comment">// isso significa que não podemos usar o Disposable obtido após a chamada do método ConnectableObservable.connect</span>
Observable&lt;String&gt; cached = observable.cache();

cached.subscribe(v -&gt; System.out.println(<span class="hljs-string">"First subscriber: "</span> + v), Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"OnComplete to first subscriber"</span>));
cached.subscribe(v -&gt; System.out.println(<span class="hljs-string">"Second subscriber: "</span> + v), Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"OnComplete to second subscriber"</span>));
</code></pre>
<h3>BehaviorSubject</h3>
<p>O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/BehaviorSubject.html">BehaviorSubject</a> emite o item mais recente e todos os subsequentes, a partir do momento da subscrição.</p>
<pre class="highlight"><code class="hljs java">BehaviorSubject&lt;String&gt; subject = BehaviorSubject.create();

subject.onNext(<span class="hljs-string">"one"</span>);
subject.subscribe(v -&gt; System.out.println(<span class="hljs-string">"First subscriber: "</span> + v));

subject.onNext(<span class="hljs-string">"two"</span>);
subject.onNext(<span class="hljs-string">"three"</span>);

subject.subscribe(v -&gt; System.out.println(<span class="hljs-string">"Second subscriber: "</span> + v));

subject.onNext(<span class="hljs-string">"four"</span>);

<span class="hljs-comment">/*
output:

First subscriber: one
First subscriber: two
First subscriber: three
Second subscriber: three
First subscriber: four
Second subscriber: four
*/</span>
</code></pre>
<p>Se ocorrer um evento terminal (<em>onCompleted</em> ou <em>onError</em>) os <em>subscribers</em> posteriores receberão apenas este evento:</p>
<pre class="highlight"><code class="hljs java">BehaviorSubject&lt;String&gt; subject = BehaviorSubject.create();

subject.onNext(<span class="hljs-string">"one"</span>);
subject.subscribe(v -&gt; System.out.println(<span class="hljs-string">"First subscriber: "</span> + v), Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"OnComplete to first subscriber"</span>));

subject.onNext(<span class="hljs-string">"two"</span>);
subject.onComplete();

subject.subscribe(v -&gt; System.out.println(<span class="hljs-string">"Second subscriber: "</span> + v), Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"OnComplete to second subscriber"</span>));

<span class="hljs-comment">/*
output:

First subscriber: one
First subscriber: two
OnComplete to first subscriber
OnComplete to second subscriber
*/</span>
</code></pre>
<p>Uma motivação comum para utilizar o <code>BehaviorSubject</code> é a necessidade de sempre ter um valor disponível para a leitura, mesmo que seja um valor padrão ou um <em>null object</em>. É possível inicializar esse objeto com um valor <em>default</em>:</p>
<pre class="highlight"><code class="hljs java">BehaviorSubject&lt;String&gt; subject = BehaviorSubject.createDefault(<span class="hljs-string">"one"</span>);

subject.subscribe(v -&gt; System.out.println(<span class="hljs-string">"First subscriber: "</span> + v));
</code></pre>
<h3>AsyncSubject</h3>
<p>O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/AsyncSubject.html">AsyncSubject</a> também armazena o último valor, mas só o emite após a ocorrência de um evento terminal.</p>
<pre class="highlight"><code class="hljs java">AsyncSubject&lt;String&gt; subject = AsyncSubject.create();

subject.subscribe(System.out::println);

subject.onNext(<span class="hljs-string">"one"</span>);
subject.onNext(<span class="hljs-string">"two"</span>);
subject.onNext(<span class="hljs-string">"three"</span>);
</code></pre>
<p>No exemplo acima, nenhuma saída é gerada, porque não houve nenhum evento terminal (<em>onCompleted</em> ou <em>onError</em>). Vejamos a diferença quando isso ocorre:</p>
<pre class="highlight"><code class="hljs java">AsyncSubject&lt;String&gt; subject = AsyncSubject.create();

subject.subscribe(System.out::println);

subject.onNext(<span class="hljs-string">"one"</span>);
subject.onNext(<span class="hljs-string">"two"</span>);

subject.onComplete(); <span class="hljs-comment">//onCompleted emitido -&gt; o último valor emitido pelo onNext será enviado ao subscriber</span>

<span class="hljs-comment">/*
output:

two
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java">AsyncSubject&lt;String&gt; subject = AsyncSubject.create();

subject.subscribe(System.out::println, Throwable::printStackTrace);

subject.onNext(<span class="hljs-string">"one"</span>);
subject.onNext(<span class="hljs-string">"two"</span>);

subject.onError(<span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"ooops"</span>)); <span class="hljs-comment">//onError emitido -&gt; apenas esse erro será enviado ao subscriber (o último valor não)</span>

<span class="hljs-comment">/*
output:

java.lang.RuntimeException: ooops
*/</span>
</code></pre>
<p>A emissão de valores para os <em>subscribers</em> subsequentes seguirá a mesma semântica: se o evento terminal foi o <em>onCompleted</em>, o <em>subscriber</em> mais recente receberá o último <em>onNext</em> e o <em>onCompleted</em>; se o evento terminal foi o <em>onError</em>, o <em>subscriber</em> mais recente receberá apenas o erro.</p>
<pre class="highlight"><code class="hljs java">AsyncSubject&lt;String&gt; subject = AsyncSubject.create();

subject.onNext(<span class="hljs-string">"one"</span>);
subject.onNext(<span class="hljs-string">"two"</span>);

subject.onComplete();

subject.subscribe(System.out::println, Throwable::printStackTrace, () -&gt; System.out.println(<span class="hljs-string">"OnCompleted"</span>));

<span class="hljs-comment">/*
output:

two
OnCompleted
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java">AsyncSubject&lt;String&gt; subject = AsyncSubject.create();

subject.onNext(<span class="hljs-string">"one"</span>);
subject.onNext(<span class="hljs-string">"two"</span>);

subject.onError(<span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"ooops"</span>));

subject.subscribe(System.out::println, Throwable::printStackTrace);

<span class="hljs-comment">/*
output:

java.lang.RuntimeException: ooops
*/</span>
</code></pre>
<h3>UnicastSubject</h3>
<p>O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/UnicastSubject.html">UnicastSubject</a> é um <code>Subject</code> que permite <strong>apenas um subscriber</strong> associado. Os eventos são armazenados em uma pilha interna, assim como na implementação do <code>ReplaySubject</code>, mas ao contrário deste, o <em>buffer</em> do <code>UnicastSubject</code> é <strong>ilimitado</strong>, sendo esvaziado apenas quando um evento terminal ocorre ou o <em>subscriber</em> é desassociado (pelo método <code>Dispose.dispose()</code>).</p>
<pre class="highlight"><code class="hljs java">UnicastSubject&lt;String&gt; subject = UnicastSubject.create();

subject.onNext(<span class="hljs-string">"one"</span>);
subject.onNext(<span class="hljs-string">"two"</span>);

subject.subscribe(System.out::println);

<span class="hljs-comment">/*
output:

one
two
*/</span>
</code></pre>
<p>Como dissemos, o <code>UnicastSubject</code> permite apenas um <em>subscriber</em>. Eis o que ocorre se tentarmos associar um segundo ouvinte de eventos:</p>
<pre class="highlight"><code class="hljs java">UnicastSubject&lt;String&gt; subject = UnicastSubject.create();

subject.onNext(<span class="hljs-string">"one"</span>);
subject.onNext(<span class="hljs-string">"two"</span>);

subject.subscribe(System.out::println, Throwable::printStackTrace);
subject.subscribe(System.out::println, Throwable::printStackTrace);

<span class="hljs-comment">/*
output:

one
two
java.lang.IllegalStateException: Only a single observer allowed. //exceção indicando que não é permitido mais de um observer
*/</span>
</code></pre>
<p>Mais informações sobre <code>Subjects</code> podem ser encontradas na documentação do <a href="http://reactivex.io/documentation/subject.html">ReactiveX</a>.</p>
<h2>Operadores reativos</h2>
<p>A programação reativa é um paradigma que opera sobre <strong>fluxos de dados observáveis</strong>, e temos objetos que representam um <em>stream</em> (Observable e etc) e outros objetos que nos permitem observar o fluxo (os <em>subscribers</em>). Mas, mais do que apenas observar, também desejamos operar, filtrar, interagir, e modificar esses dados, e os frameworks que implementam o paradigma reativo fornecem uma fantástica caixa de ferramentas para esse propósito: os <a href="http://reactivex.io/documentation/operators.html">operadores reativos</a>, uma enorme quantidade de métodos e operações que efetivamente fazem a mágica acontecer. É importante relembrar que os operadores <strong>não modificam o fluxo de dados</strong>, pois um dos fundamentos da programação reativa é a <strong>propagação de estado</strong>; portanto, todos os operadores criam novos objetos imutáveis, com efeito, propagando o novo estado (o dado modificado) para o novo <em>stream</em>.</p>
<h3>Marble diagrams</h3>
<p>O comportamento dos métodos reativos são demonstrados visualmente na documentação do Rx usando &quot;marble diagrams&quot;, que demonstram uma <strong>sequência de eventos ordenados no tempo</strong>, que é o conceito principal que os objetos reativos representam. Uma explicação rápida dos conceitos nesse diagrama pode nos ser útil antes de nos aprofundarmos nesses métodos.</p>
<p>Essa é uma simples linha do tempo, sobre a qual os eventos ocorrem:</p>
<p><img src="/images/programacao-reativa-parte-2-1.png" alt="Uma linha do tempo"></p>
<p>Os elementos emitidos são representados por figuras geométricas. Na imagem abaixo, três itens são emitidos e o <code>stream</code> é completado (três eventos <em>onNext</em> e o evento <em>onCompleted</em>, portanto). A linha vertical representa o <em>onCompleted</em>.</p>
<p><img src="/images/programacao-reativa-parte-2-2.png" alt="Três itens emitidos e o evento onCompleted"></p>
<p>Abaixo, três itens são emitidos, seguidos de um erro (três eventos <em>onNext</em> e o evento <em>onError</em>). O &quot;X&quot; representa o <em>onError</em>.</p>
<p><img src="/images/programacao-reativa-parte-2-3.png" alt="Três itens emitidos e o evento onError"></p>
<p>Juntando tudo, uma operação reativa completa sobre a linha do tempo seria representada da seguinte forma:</p>
<p><img src="/images/programacao-reativa-parte-2-4.png" alt="Marble diagram completo"></p>
<p>Um <em>site</em> que demonstra esses diagramas de forma simples é o <a href="http://rxmarbles.com/">RxMarbles</a>, que utilizo bastante. No decorrer do post, vou utilizar diagramas retirados da documentação do RxJava para demonstrar o comportamento de cada operador.</p>
<h3>Métodos com efeitos colaterais</h3>
<p>Antes de falarmos dos operadores (que são, com efeito, os principais métodos dos frameworks Rx), é importante conhecer os <a href="http://reactivex.io/documentation/operators/do.html">side-effect methods</a>: os métodos <em>do</em>. Esses métodos não modificam os dados (não trabalham com a <em>propagação de estado</em> do fluxo) e não criam novos <code>streams</code>, pois foram concebidos para efetivamente gerar efeitos colaterais durante a emissão de eventos. Dado que o <code>Observable</code> (e os outros) são objetos imutáveis, esses métodos não afetam o seu estado, mas permitem associar comportamentos <strong>quando determinados eventos ocorrerem</strong>; como operam apenas sobre os eventos, e não sobre o <code>pipeline</code> de transformação do <code>stream</code>, funcionam como <em>hooks</em> ou <em>callbacks</em> da ocorrência de cada evento, permitindo realizar ações muito específicas. São muito úteis para <em>logging</em> e depuração.</p>
<pre class="highlight"><code class="hljs java">Observable&lt;String&gt; observable = Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>);

observable
    .doOnSubscribe(d -&gt; System.out.println(<span class="hljs-string">"DoOnSubscribe: "</span> + d))         <span class="hljs-comment">// quando um subscriber se registra</span>
    .doOnEach(v -&gt; System.out.println(<span class="hljs-string">"DoOnEach:"</span> + v))                    <span class="hljs-comment">// quando ocorre qualquer evento; o parâmetro é um objeto do tipo Notification</span>
    .doOnNext(v -&gt; System.out.println(<span class="hljs-string">"DoOnNext: "</span> + v))                <span class="hljs-comment">// quando ocorre o evento onNext</span>
    .doOnError(t -&gt; System.out.println(<span class="hljs-string">"DoOnError: "</span> + t))                <span class="hljs-comment">// quando ocorre o evento onError</span>
    .doOnComplete(() -&gt; System.out.println(<span class="hljs-string">"DoOnComplete"</span>))                <span class="hljs-comment">// quando ocorre o evento onComplete</span>
    .doAfterNext(v -&gt; System.out.println(<span class="hljs-string">"DoAfterNext: "</span> + v))            <span class="hljs-comment">// após a ocorrência do evento onNext</span>
    .doOnTerminate(() -&gt; System.out.println(<span class="hljs-string">"DoOnTerminate"</span>))            <span class="hljs-comment">// quando ocorre um evento terminal</span>
    .doAfterTerminate(() -&gt; System.out.println(<span class="hljs-string">"DoAfterTerminate"</span>))        <span class="hljs-comment">// após a ocorrência de um evento terminal</span>
    .doFinally(() -&gt; System.out.println(<span class="hljs-string">"DoFinally"</span>))                    <span class="hljs-comment">// quando ocorre um evento terminal, ou quando um subscriber se desvincula do stream</span>
    .subscribe(); <span class="hljs-comment">// os callbacks acima são invocados para cada subscriber</span>

<span class="hljs-comment">/*
output:
DoOnSubscribe: io.reactivex.internal.observers.DisposableLambdaObserver@57fffcd7
DoOnEach:OnNextNotification[one]
DoOnNext: one
DoAfterNext: one
DoOnEach:OnNextNotification[two]
DoOnNext: two
DoAfterNext: two
DoOnEach:OnNextNotification[three]
DoOnNext: three
DoAfterNext: three
DoOnEach:OnCompleteNotification
DoOnComplete
DoOnTerminate
DoFinally
DoAfterTerminate
*/</span>
</code></pre>
<p>Novamente, é importante destacar que nenhum dos métodos acima representa uma subscrição, e sim <em>callbacks</em> específicos para cada evento.</p>
<h3>Agora, sim: operadores reativos!</h3>
<p>No caso do RxJava, que estamos utilizando aqui, o <code>Observable</code> possui <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html">dezenas de métodos</a> (sim, dezenas), e seria cansativo detalhar todos aqui. Vamos ver algumas demonstrações dos operadores que considero mais úteis e interessantes.</p>
<h3>Criação</h3>
<h4>create</h4>
<p><img src="/images/programacao-reativa-parte-2-5.png" alt="create"></p>
<p>O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html">create</a> é uma maneira simples de criar um <em>cold observable</em>. Ele recebe como parâmetro um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/ObservableOnSubscribe.html">ObservableOnSubscribe</a>, que pode ser representado como uma função que recebe um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/ObservableEmitter.html">ObservableEmitter</a>, um objeto que permite emitir eventos explicitamente.</p>
<pre class="highlight"><code class="hljs java">Observable&lt;String&gt; observable = Observable.create(e -&gt; e.onNext(<span class="hljs-string">"hello"</span>));

observable.subscribe(System.out::println);

<span class="hljs-comment">/*
output:

hello
*/</span>
</code></pre>
<h4>defer</h4>
<p><img src="/images/programacao-reativa-parte-2-6.png" alt="defer"></p>
<p>No exemplo acima, o <code>ObservableOnSubscribe</code> será invocado para cada subscrição realizada (um <em>cold observable</em>, portanto). Podemos ter algum caso de uso onde queremos gerar <strong>preguiçosamente</strong> os valores emitidos, e o método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#defer-java.util.concurrent.Callable-">defer</a> permite fornecer uma fábrica (representada por um <code>Callable</code>) para a criação do <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/ObservableSource.html">ObservableSource</a>, que será executado a cada subscrição.</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-comment">// a diferença aqui é que o parâmetro representa um função que devolve um ObservableSource,</span>
<span class="hljs-comment">// que pode ser gerado de maneira "lazy"</span>
Observable&lt;String&gt; observable = Observable.defer(() -&gt; Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>));

observable.subscribe(System.out::println);

<span class="hljs-comment">/*
output:

one
two
*/</span>
</code></pre>
<h4>empty, never, error</h4>
<p><img src="/images/programacao-reativa-parte-2-7.png" alt="empty"></p>
<p>O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#empty--">empty</a> devolve um <code>Observable</code> que não emite nenhum valor, e emite imediatamente o evento <em>onCompleted</em> quando ocorre um subscrição:</p>
<pre class="highlight"><code class="hljs java">Observable.empty()
        .doOnComplete(() -&gt; System.out.println(<span class="hljs-string">"OnComplete"</span>))
        .subscribe();

<span class="hljs-comment">/*
output:

OnComplete
*/</span>
</code></pre>
<p><img src="/images/programacao-reativa-parte-2-8.png" alt="never"></p>
<p>O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#never--">never</a> devolve um <code>Observable</code> que nunca notifica nenhum <em>subscriber</em>. Isso é útil para ser utilizado como <em>null object</em>.</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-comment">// nenhuma saída é gerada para o código abaixo</span>
Observable.never()
        .doOnNext(System.out::println)
        .doOnComplete(() -&gt; System.out.println(<span class="hljs-string">"OnComplete"</span>))
        .subscribe();

</code></pre>
<p><img src="/images/programacao-reativa-parte-2-9.png" alt="error"></p>
<p>O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#error-java.lang.Throwable-">error</a> devolve um <code>Observable</code> que imediatamente emite o evento <em>onError</em>. Também há uma <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#error-java.util.concurrent.Callable-">sobrecarga</a> desse método que recebe um <code>Callable</code>, permitindo gerar a exceção de maneira <em>lazy</em>.</p>
<pre class="highlight"><code class="hljs java">Observable.error(<span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"ooops..."</span>))
        .subscribe(System.out::println, Throwable::printStackTrace);

<span class="hljs-comment">/*
output:

java.lang.RuntimeException: ooops...
*/</span>
</code></pre>
<h4>from</h4>
<p>Existe uma variedade de métodos <em>from</em>: <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromArray-T...-">fromArray</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromCallable-java.util.concurrent.Callable-">fromCallable</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromFuture-java.util.concurrent.Future-">fromFuture</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromIterable-java.lang.Iterable-">fromIterable</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromPublisher-org.reactivestreams.Publisher-">fromPublisher</a>: a motivação desses métodos é converter outros tipos de objetos e estruturas de dados para um <code>Observable</code>.</p>
<h4>just</h4>
<p><img src="/images/programacao-reativa-parte-2-10.png" alt="just"></p>
<p>Utilizado em praticamente todos os exemplos desse post, o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#just-T-">just</a> simplesmente cria um <code>Observable</code> a partir de uma lista de valores, emitindo todos através do evento <em>onNext</em>.</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>)
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

one
two
three
*/</span>
</code></pre>
<h4>range</h4>
<p><img src="/images/programacao-reativa-parte-2-11.png" alt="range"></p>
<p>O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#range-int-int-">range</a> devolve um <code>Observable</code> que emite uma sequência de valores do tipo <code>Integer</code> dentro do intervalo especificado (há uma sobrecarga que emite valores do tipo <code>Long</code>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#rangeLong-long-long-">rangeLong</a>) .</p>
<pre class="highlight"><code class="hljs java">Observable.range(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

0
1
2
3
4
*/</span>
</code></pre>
<h4>interval e timer</h4>
<p><img src="/images/programacao-reativa-parte-2-12.png" alt="interval"></p>
<p>O método <a href="interval">interval</a> devolve um <code>Observable</code> que emite um valor do tipo <code>Long</code> a cada intervalo de tempo especificado. Há uma sobrecarga em que é possível configurar um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#interval-long-long-java.util.concurrent.TimeUnit-">delay inicial</a>.</p>
<pre class="highlight"><code class="hljs java">Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
        .doOnNext(System.out::println)
        .subscribe();


Thread.sleep(<span class="hljs-number">5000</span>);

<span class="hljs-comment">/*
output:

0
1
2
3
4
*/</span>
</code></pre>
<p><img src="/images/programacao-reativa-parte-2-13.png" alt="timer"></p>
<p>Já com o método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#timer-long-java.util.concurrent.TimeUnit-">timer</a>, o <code>Observable</code> criado irá emitir o valor 0 (<code>Long</code>) após o intervalo de tempo especificado, e depois o evento <em>onCompleted</em>.</p>
<pre class="highlight"><code class="hljs java">Observable.timer(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
        .doOnNext(System.out::println)
        .doOnComplete(() -&gt; System.out.println(<span class="hljs-string">"Completed"</span>))
        .subscribe();

Thread.sleep(<span class="hljs-number">1500</span>);

<span class="hljs-comment">/*
output:

0
Completed
*/</span>
</code></pre>
<h3>Transformação</h3>
<h4>map</h4>
<p><img src="/images/programacao-reativa-parte-2-14.png" alt="map"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#map-io.reactivex.functions.Function-">map</a> devolve um <code>Observable</code> que aplica uma função de transformação para cada item emitido, e então emite os novos valores.</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>)
        .map(value -&gt; <span class="hljs-string">"Hello, i'm "</span> + value) <span class="hljs-comment">//lembrete importante: o retorno desse operador é um novo Observable (do tipo retornado pela função)</span>
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

Hello, i'm one
Hello, i'm two
Hello, i'm three
*/</span>
</code></pre>
<h4>flatMap</h4>
<p><img src="/images/programacao-reativa-parte-2-15.png" alt="flatMap"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#flatMap-io.reactivex.functions.Function-">flatMap</a> devolve um <code>Observable</code> que, para cada item, aplica uma função de transformação <strong>que devolve um novo Observable</strong>; todos os novos <code>Observables</code> gerados para cada chamada da função são então mergeados e &quot;achatados&quot; (essa operação se chama <em>flattern</em>) em um novo <code>Observable</code>.</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>)
        .flatMap(value -&gt; Observable.just(<span class="hljs-string">"Hello, i'm "</span> + value))
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

Hello, i'm one
Hello, i'm two
Hello, i'm three
*/</span>
</code></pre>
<h4>timestamp</h4>
<p><img src="/images/programacao-reativa-parte-2-16.png" alt="timestamp"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#timestamp--">timestamp</a> encapsula cada item emitido em um objeto do tipo <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/schedulers/Timed.html">Timed</a>, contendo o <em>timestamp</em> do momento em que o <em>onNext</em> ocorreu e o valor.</p>
<pre class="highlight"><code class="hljs java">Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
    .timestamp()
    .map(t -&gt; <span class="hljs-string">"Timestamp: "</span> + t.time() + <span class="hljs-string">", and value: "</span> + t.value())
    .subscribe(System.out::println);

Thread.sleep(<span class="hljs-number">5000</span>);

<span class="hljs-comment">/*
output:

Timestamp: 1523914485689, and value: 0
Timestamp: 1523914486689, and value: 1
Timestamp: 1523914487689, and value: 2
Timestamp: 1523914488691, and value: 3
Timestamp: 1523914489692, and value: 4
*/</span>
</code></pre>
<h3>Agregação e acumulação</h3>
<h4>groupBy</h4>
<p><img src="/images/programacao-reativa-parte-2-17.png" alt="groupBy"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#groupBy-io.reactivex.functions.Function-">groupBy</a> permite o agrupamento de valores emitidos a partir do critério implementado na função, e devolve um <code>Observable</code> que emite valores do tipo <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/observables/GroupedObservable.html">GroupedObservable</a>; o retorno da função será a chave de agrupamento que pode ser recuperada em cada <code>GroupedObservable</code>. Esse objeto também é um <code>Observable</code>, então podemos nos subscrever nele para obter os valores do grupo.</p>
<pre class="highlight"><code class="hljs java">Observable.range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)
        .groupBy(value -&gt; value % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-string">"even"</span> : <span class="hljs-string">"odd"</span>) <span class="hljs-comment">// "even" ou "odd" serão as chaves de agrupamento; são avaliadas para cada valor emitido</span>
        .subscribe(group -&gt; {

            <span class="hljs-comment">// group é do tipo GroupedObservable</span>
            group.subscribe(value -&gt; System.out.println(<span class="hljs-string">"Group "</span> + group.getKey() + <span class="hljs-string">" and value "</span> + value));

        });

<span class="hljs-comment">/*
output:

Group even and value 0
Group odd and value 1
Group even and value 2
Group odd and value 3
Group even and value 4
Group odd and value 5
Group even and value 6
Group odd and value 7
Group even and value 8
Group odd and value 9
*/</span>
</code></pre>
<h4>buffer</h4>
<p><img src="/images/programacao-reativa-parte-2-18.png" alt="buffer"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#buffer-int-">buffer</a> coleta os items emitidos baseado em um parâmetro de quantidade de elementos ou tempo transcorrido, e gera um novo <code>Observable</code> com um <code>List</code> dos valores bufferizados.</p>
<pre class="highlight"><code class="hljs java">Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
    .buffer(<span class="hljs-number">2</span>) <span class="hljs-comment">//buffer a cada dois elementos emitidos</span>
    .doOnNext(System.out::println)
    .subscribe();

Thread.sleep(<span class="hljs-number">10000</span>);

<span class="hljs-comment">/*
output:

[0, 1] // um valor do tipo java.util.List é emitido no onNext
[2, 3]
[4, 5]
[6, 7]
[8, 9]
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java">Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
    .buffer(<span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS) <span class="hljs-comment">// buffer a cada dois segundos</span>
    .doOnNext(System.out::println)
    .subscribe();

Thread.sleep(<span class="hljs-number">10000</span>);

<span class="hljs-comment">/*
output: // essa saída pode ter variacões

[0, 1]
[2, 3]
[4, 5]
[6, 7]
[8, 9]
*/</span>
</code></pre>
<h4>reduce</h4>
<p><img src="/images/programacao-reativa-parte-2-19.png" alt="reduce"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#reduce-io.reactivex.functions.BiFunction-">reduce</a> aplica uma função de acumulação sobre o conjunto de items emitidos pelo <code>Observable</code>; a função é aplicada ao primeiro valor, e o retorno é reenviado à mesma função com o segundo valor, e assim sucessivamente, reduzindo o conjunto a um único valor final. Essa operação é chamada no RxJava de &quot;reduce&quot; (nome mais comum), mas também é conhecida como &quot;fold&quot; (mais comum em linguagens funcionais), &quot;accumulate&quot;, &quot;aggregate&quot;, dependendo do contexto. É importante observar que esse operador só pode gerar um valor de retorno após o evento <em>onCompleted</em> do <code>Observable</code> original, então essa operação é mais convenientemente aplicada em <code>streams</code> finitos. Um <code>Observable</code> infinito pode nunca emitir o <em>onCompleted</em>, podendo gerar um <code>OutOfMemoryError</code> pelo acúmulo de valores.</p>
<p>O parâmetro desse operador é um <code>BiFunction</code>, uma interface funcional do Java que representa uma função com dois argumentos e retorna um valor qualquer. O retorno é do tipo <code>Maybe</code>.</p>
<pre class="highlight"><code class="hljs java">Observable.range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)
        .doOnNext(System.out::println) <span class="hljs-comment">// imprime cada valor emitido no range</span>
        .reduce((a, b) -&gt; a + b) <span class="hljs-comment">//soma todos os valores emitidos no range</span>
        .doOnSuccess(r -&gt; System.out.println(<span class="hljs-string">"Reduce: "</span> + r))
        .subscribe();

<span class="hljs-comment">/*
output:

1
2
3
4
5
6
7
8
9
10
Reduce: 55
*/</span>
</code></pre>
<p>Existe uma <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#reduce-R-io.reactivex.functions.BiFunction-">sobrecarga</a> que permite passar à função um valor inicial:</p>
<pre class="highlight"><code class="hljs java">Observable.range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)
        .doOnNext(System.out::println)
        .reduce(<span class="hljs-number">100</span>, (a, b) -&gt; a + b) <span class="hljs-comment">//100 é o valor inicial passado à função</span>
        .doOnSuccess(r -&gt; System.out.println(<span class="hljs-string">"Reduce: "</span> + r))
        .subscribe();

<span class="hljs-comment">/*
output:

1
2
3
4
5
6
7
8
9
10
Reduce: 155
*/</span>
</code></pre>
<h4>scan</h4>
<p><img src="/images/programacao-reativa-parte-2-20.png" alt="scan"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#scan-io.reactivex.functions.BiFunction-">scan</a> devolve um <code>Observable</code> que aplica uma função de acumulação sobre os valores emitidos, repassando o novo valor para a função subsequente. Cada retorno da função é emitido pelo novo <code>Observable</code>, diferindo, pois, de uma operação de redução, que gera um único valor final.</p>
<pre class="highlight"><code class="hljs java">Observable.range(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)
        .doOnNext(v -&gt; System.out.println(<span class="hljs-string">"Value is: "</span> + v)) <span class="hljs-comment">// valores emitidos do range</span>
        .scan((a, b) -&gt; a + b) <span class="hljs-comment">// o primeiro parâmetro é o resultado acumulado; o segundo é o valor emitido</span>
        .doOnNext(v -&gt; System.out.println(<span class="hljs-string">"Scan result is: "</span> + v)) <span class="hljs-comment">// resultado da função passada ao scan</span>
        .subscribe();

<span class="hljs-comment">/*
output:

Value is: 0 // valor emitido pelo range
Scan result is: 0 // nenhum valor acumulado - a função não é aplicada

Value is: 1 // valor emitido pelo range
Scan result is: 1 // 0 + 1 = 1 (esse resultado será passado para a função subsequente)

Value is: 2 // valor emitido pelo range
Scan result is: 3 // 1 + 2 = 3 (e sucessivamente...)

Value is: 3 // valor emitido pelo range
Scan result is: 6 // 3 + 3 = 6

Value is: 4 // valor emitido pelo range
Scan result is: 10 // 6 + 4 = 10
*/</span>
</code></pre>
<h4>collect</h4>
<p><img src="/images/programacao-reativa-parte-2-21.png" alt="collect"></p>
<p>Outra operação comum é o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#collect-java.util.concurrent.Callable-io.reactivex.functions.BiConsumer-">collect</a>, que permite coletar os elementos, conforme eles são emitidos, dentro de uma estrutura mutável, como uma <code>Collection</code>:</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>)
        .collect(ArrayList::<span class="hljs-keyword">new</span>, (l, v) -&gt; l.add(v)) <span class="hljs-comment">// o retorno é um Single&lt;ArrayList&gt;</span>
        .doOnSuccess(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

[one, two, three, four]
*/</span>
</code></pre>
<h3>Temporização</h3>
<h4>window</h4>
<p><img src="/images/programacao-reativa-parte-2-22.png" alt="window"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#window-long-">window</a> permite o agrupamento de items em &quot;janelas&quot;, definidas por quantidade ou tempo. É essencialmente igual ao <code>buffer</code>, com a diferença que os valores são agrupados em um <code>Observable</code> ao invés de um <code>List</code>.</p>
<pre class="highlight"><code class="hljs java">Observable.range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)
        .window(<span class="hljs-number">3</span>) <span class="hljs-comment">// janela com três elementos</span>
        .subscribe(window -&gt; window.toList().subscribe(System.out::println)); <span class="hljs-comment">// window é um Observable</span>

<span class="hljs-comment">/*
output:

[0, 1, 2]
[3, 4, 5]
[6, 7, 8]
[9]
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java">Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
    .window(<span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS) <span class="hljs-comment">// janela de dois segundos</span>
    .subscribe(window -&gt; window.toList().subscribe(System.out::println));

Thread.sleep(<span class="hljs-number">10000</span>);

<span class="hljs-comment">/*
output: // essa saída pode ter variações

[0, 1]
[2]
[3, 4, 5]
[6, 7]
[8, 9]
*/</span>
</code></pre>
<h4>throttle</h4>
<p>Existem três sabores desse operador: <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#throttleFirst-long-java.util.concurrent.TimeUnit-">throttleFirst</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#throttleLast-long-java.util.concurrent.TimeUnit-">throttleLast</a>, e <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#throttleWithTimeout-long-java.util.concurrent.TimeUnit-">throttleWithTimeout</a>. Os três aplicam uma <strong>supressão</strong> (selecionam um elemento e descartam os demais) sobre os items emitidos dentro de uma janela de tempo, gerando um <code>Observable</code> que reemite o valor adequado, dependendo do caso.</p>
<p>Os operadores <code>throttleFirst</code> e <code>throttleLast</code> geram um <code>Observable</code> que emite <strong>apenas o primeiro ou último item emitidos dentro do intervalo</strong>, descartando os demais.</p>
<p><img src="/images/programacao-reativa-parte-2-23.png" alt="throttleFirst"></p>
<pre class="highlight"><code class="hljs java">Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
    .throttleFirst(<span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS) <span class="hljs-comment">// reemite apenas o primeiro valor emitido dentro de uma janela de três segundos</span>
    .doOnNext(System.out::println)
    .subscribe();

Thread.sleep(<span class="hljs-number">10000</span>);

<span class="hljs-comment">/*
output:

0
4
8
*/</span>
</code></pre>
<p><img src="/images/programacao-reativa-parte-2-24.png" alt="throttleLast"></p>
<pre class="highlight"><code class="hljs java">Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS) <span class="hljs-comment">// emite um valor a cada segundo</span>
    .throttleLast(<span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS) <span class="hljs-comment">// reemite apenas o último valor emitido dentro de uma janela de três segundos</span>
    .doOnNext(System.out::println)
    .subscribe();

Thread.sleep(<span class="hljs-number">10000</span>);

<span class="hljs-comment">/*
output:

2
4
8
*/</span>
</code></pre>
<p>O operador <code>throttleWithTimeout</code> faz algo diferente: cria um <code>Observable</code> que reemite apenas o item que <strong>não foi seguido por nenhuma outra emissão</strong> dentro do intervalo.</p>
<p><img src="/images/programacao-reativa-parte-2-25.png" alt="throttleWithTimeout"></p>
<pre class="highlight"><code class="hljs java">Observable.interval(<span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS) <span class="hljs-comment">// emite um valor a cada três segundos</span>
        .doOnNext(v -&gt; System.out.println(<span class="hljs-string">"Interval: "</span> + v))
        .throttleWithTimeout(<span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS) <span class="hljs-comment">// emite apenas o item que não foi seguido por nenhum outro, dentro do intervalo</span>
        .doOnNext(v -&gt; System.out.println(<span class="hljs-string">"Throttled: "</span> + v))
        .subscribe();

Thread.sleep(<span class="hljs-number">15000</span>);

<span class="hljs-comment">/*
output:

Interval: 0        // emitido em 3s
Throttled: 0    // essa emissão não foi seguida por nenhum outra dentro de 2s

// a mesma lógica se aplica aos items abaixo
Interval: 1
Throttled: 1

Interval: 2
Throttled: 2

Interval: 3
Throttled: 3

Interval: 4
*/</span>
</code></pre>
<h4>debounce</h4>
<p><img src="/images/programacao-reativa-parte-2-26.png" alt="debounce"></p>
<p>O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#debounce-long-java.util.concurrent.TimeUnit-">debounce</a> têm o mesmo comportamento do <code>throttleWithTimeout</code>; devolve um <code>Observable</code> que inicializa um janela de tempo, e reemite os valores que não foram seguidos por nenhum outro dentro do intervalo (items que não satisfazem essa condição são descartados).</p>
<pre class="highlight"><code class="hljs java">Observable.interval(<span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS) <span class="hljs-comment">// emite um valor a cada três segundos</span>
        .doOnNext(v -&gt; System.out.println(<span class="hljs-string">"Interval: "</span> + v))
        .debounce(<span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS) <span class="hljs-comment">// emite apenas o item que não foi seguido por nenhum outro, dentro do intervalo</span>
        .doOnNext(v -&gt; System.out.println(<span class="hljs-string">"Debounced: "</span> + v))
        .subscribe();

Thread.sleep(<span class="hljs-number">15000</span>);

<span class="hljs-comment">/*
Interval: 0        // emitido em 3s
Debounced: 0    // essa emissão não foi seguida por nenhum outra dentro de 2s

// a mesma lógica se aplica aos items abaixo
Interval: 1
Debounced: 1

Interval: 2
Debounced: 2

Interval: 3
Debounced: 3

Interval: 4
*/</span>
</code></pre>
<p>Uma possibilidade interessante desse operador é definir uma janela de tempo para cada item, usando <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#debounce-io.reactivex.functions.Function-">uma sobrecarga</a> que recebe uma funcão onde é possível calcular o tempo de duração da janela (isso é sinalizado criando um novo <code>Observable</code> para cada item).</p>
<pre class="highlight"><code class="hljs java">Observable.interval(<span class="hljs-number">1500</span>, TimeUnit.MILLISECONDS)
    .doOnNext(v -&gt; System.out.println(<span class="hljs-string">"Interval: "</span> + v))
    .debounce(value -&gt; Observable.timer((value + <span class="hljs-number">1</span>) * <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)) <span class="hljs-comment">// calcula uma janela de tempo para cada item</span>
    .doOnNext(v -&gt; System.out.println(<span class="hljs-string">"Debounced: "</span> + v))
    .subscribe();

Thread.sleep(<span class="hljs-number">15000</span>);


<span class="hljs-comment">/*
output:

Observable.interval(1500, TimeUnit.MILLISECONDS)
    .doOnNext(v -&gt; System.out.println("Interval: " + v))
    .debounce(value -&gt; Observable.timer((value + 1) * 1000, TimeUnit.MILLISECONDS))
    .doOnNext(v -&gt; System.out.println("Debounced: " + v))
    .subscribe();

Thread.sleep(15000);
*/</span>
</code></pre>
<h3>Captura de elementos</h3>
<h4>forEach</h4>
<p><img src="/images/programacao-reativa-parte-2-27.png" alt="forEach"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#forEach-io.reactivex.functions.Consumer-">forEach</a> é essencialmente um <em>alias</em> para o método <code>subscribe</code>.</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>)
        .forEach(System.out::println);

<span class="hljs-comment">/*
output:

one
two
three
*/</span>
</code></pre>
<h4>filter</h4>
<p><img src="/images/programacao-reativa-parte-2-28.png" alt="filter"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#filter-io.reactivex.functions.Predicate-">filter</a> filtra items emitidos utilizando um <code>Predicate</code>:</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>)
        .filter(v -&gt; v.equals(<span class="hljs-string">"one"</span>))
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

one
*/</span>
</code></pre>
<h4>distinct</h4>
<p><img src="/images/programacao-reativa-parte-2-29.png" alt="distinct"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#distinct--">distinct</a> elimina items duplicados <strong>em qualquer momento da sequência emissão</strong> (a comparação é feita usando o <code>equals</code> do objeto):</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"one"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"one"</span>, <span class="hljs-string">"four"</span>)
        .distinct()
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

one
two
three
four
*/</span>
</code></pre>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#distinctUntilChanged--">distinctUntilChanged</a> é ligeiramente diferente, pois a comparação é feita apenas com o item anterior da sequência. O mesmo código anterior produziria a saída:</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"one"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"one"</span>, <span class="hljs-string">"four"</span>)
        .distinct()
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

one
two
one
three
one
four
*/</span>
</code></pre>
<p>O código abaixo demonstra bem a motivação do <code>distinctUntilChanged</code>:</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"one"</span>, <span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"one"</span>, <span class="hljs-string">"three"</span>)
        .distinctUntilChanged()
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

one
two
one
three
*/</span>
</code></pre>
<h4>first</h4>
<p><img src="/images/programacao-reativa-parte-2-30.png" alt="first"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#first-T-">first</a> devolve um <code>Single</code> que emite o primeiro valor da sequência, ou um valor padrão caso o <code>Observable</code> seja completado sem emitir valores.</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>)
        .first(<span class="hljs-string">"zero"</span>) <span class="hljs-comment">//esse método devolve um Single</span>
        .doOnSuccess(System.out::println) <span class="hljs-comment">//o Single emite o evento onSuccess</span>
        .subscribe();

<span class="hljs-comment">/*
output:

one
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java">Observable.empty()
        .first(<span class="hljs-string">"zero"</span>)
        .doOnSuccess(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

zero
*/</span>
</code></pre>
<p>Existem outros sabores desse operadores. O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#firstElement--">firstElement</a> também retorna o primeiro valor da sequência, mas sem um valor padrão caso o mesmo não exista; como, então, o <code>Observable</code> <strong>talvez</strong> emitirá algo, o tipo do retorno é um <code>Maybe</code>:</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>)
        .firstElement() <span class="hljs-comment">//esse método devolve um Maybe</span>
        .doOnSuccess(System.out::println) <span class="hljs-comment">//o Maybe emite o evento onSuccess</span>
        .subscribe();

<span class="hljs-comment">/*
output:

one
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java">Observable.empty()
        .firstElement()
        .doOnSuccess(System.out::println)
        .doOnComplete(() -&gt; System.out.println(<span class="hljs-string">"OnCompleted"</span>))
        .subscribe();

<span class="hljs-comment">/*
output:

OnCompleted
*/</span>
</code></pre>
<p>Já o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#firstOrError--">firstOrError</a> retorna um <code>Single</code> que pode emitir o primeiro valor da sequência, ou um <code>NoSuchElementException</code> caso o <code>Observable</code> não emita nada:</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>)
        .firstOrError()
        .doOnSuccess(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

one
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java">Observable.empty()
        .firstOrError()
        .doOnError(Throwable::printStackTrace)
        .subscribe();

<span class="hljs-comment">/*
output:

java.util.NoSuchElementException
    ...
*/</span>
</code></pre>
<p>Existem também mais dois operadores semelhantes, chamados <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#single-T-">single</a> e <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#singleElement--">singleElement</a>, que convertem um <code>Observable</code> em um <code>Single</code> (caso do método <em>single</em>, que recebe um valor padrão) ou em um <code>Maybe</code> (caso do <em>singleElement</em>). Semânticamente eles são mais elegantes, mas use-os com cuidado porque o objeto resultante irá emitir um erro caso o <code>Observable</code> original emita mais de um valor.</p>
<h4>last</h4>
<p><img src="/images/programacao-reativa-parte-2-31.png" alt="last"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#last-T-">last</a>, naturalmente, tem um comportamento oposto ao <code>first</code>, devolvendo o último valor emitido.</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>)
        .last(<span class="hljs-string">"zero"</span>)
        .doOnSuccess(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

one
*/</span>
</code></pre>
<p>Assim como o <code>first</code>, o método <code>last</code> também vem ns sabores <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#lastElement--">lastElement</a> e <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#lastOrError--">lastOrError</a>.</p>
<h4>elementAt</h4>
<p><img src="/images/programacao-reativa-parte-2-32.png" alt="elementAt"></p>
<p>O operator <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#elementAt-long-">elementAt</a> permite recuperar um valor emitido a partir do seu índice (iniciando em zero); o retorno é encapsulado em um <code>Maybe</code>, portanto, caso o índice em questão não exista, o evento <em>onError</em> não será emitido mas o <code>Maybe</code> será completado sem emitir nada.</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>)
        .elementAt(<span class="hljs-number">1</span>)
        .doOnSuccess(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

two
*/</span>

```java
Observable.empty()
        .elementAt(<span class="hljs-number">1</span>)
        .doOnSuccess(System.out::println)
        .doOnComplete(() -&gt; System.out.println(<span class="hljs-string">"OnComplete"</span>))
        .subscribe();

<span class="hljs-comment">/*
output:

OnComplete
*/</span>
</code></pre>
<p>Outros sabores desse método são uma <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#elementAt-long-T-">sobrecarga</a> que permite passar um valor padrão caso o índice não exista na sequência, e o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#elementAtOrError-long-">elementAtOrError</a>, que devolve um <code>Single</code> que irá publicar o evento <em>onError</em> (com a exceção <code>NoSuchElementException</code>) caso o índice não exista.</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>)
        .elementAtOrError(<span class="hljs-number">1</span>)
        .doOnSuccess(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

two
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>)
        .elementAtOrError(<span class="hljs-number">10</span>)
        .doOnSuccess(System.out::println)
        .doOnError(Throwable::printStackTrace)
        .subscribe();

<span class="hljs-comment">/*
output:

java.util.NoSuchElementException
    ...
*/</span>
</code></pre>
<h4>take</h4>
<p><img src="/images/programacao-reativa-parte-2-33.png" alt="take"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#take-long-">take</a> permite obter os <em>n</em> primeiros elementos emitidos:</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>)
    .take(<span class="hljs-number">2</span>)
    .doOnNext(System.out::println)
    .subscribe();

<span class="hljs-comment">/*
output:

one
two
*/</span>
</code></pre>
<p>Também é possível obter os <em>n</em> últimos com o operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#takeLast-int-">takeLast</a>:</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>)
    .takeLast(<span class="hljs-number">2</span>)
    .doOnNext(System.out::println)
    .subscribe();

<span class="hljs-comment">/*
output:

three
four
*/</span>
</code></pre>
<h4>skip</h4>
<p><img src="/images/programacao-reativa-parte-2-34.png" alt="skip"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#skip-long-">skip</a> descarta os primeiros <em>n</em> elementos emitidos:</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>)
        .skip(<span class="hljs-number">2</span>)
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

three
four
*/</span>
</code></pre>
<p>Já o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#skipLast-int-">skipLast</a> descarta os <em>n</em> últimos:</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>)
        .skipLast(<span class="hljs-number">2</span>)
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

one
two
*/</span>
</code></pre>
<h4>skipWhile e skipUntil</h4>
<p><img src="/images/programacao-reativa-parte-2-35.png" alt="skipWhile"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#skipWhile-io.reactivex.functions.Predicate-">skipWhile</a> recebe como parâmetro um <code>Predicate</code>, omitindo os itens emitidos da sequência <strong>enquanto essa condição for verdadeira</strong>, e emite todos os items subsequentes a partir do elemento para o qual a condição for falsa:</p>
<pre class="highlight"><code class="hljs java">Observable.range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)
        .skipWhile(v -&gt; v &lt; <span class="hljs-number">5</span>) <span class="hljs-comment">//omite todos os elements menores que 5</span>
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

5
6
7
8
9
*/</span>
</code></pre>
<p><img src="/images/programacao-reativa-parte-2-36.png" alt="skipUntil"></p>
<p>Já o [skipUntil] recebe um segundo <code>Observable</code>, e devolve um <code>stream</code> que omite todos os itens até que o segundo <code>Observable</code> emita algum valor:</p>
<pre class="highlight"><code class="hljs java">
Observable&lt;Long&gt; timer = Observable.timer(<span class="hljs-number">5000</span>, TimeUnit.MILLISECONDS); <span class="hljs-comment">// emite um valor a cada 5 segundos</span>

<span class="hljs-comment">// o operador skipUntil fará com que o Observable abaixo aguarde o timer emitir algo;</span>
<span class="hljs-comment">// ou seja, apesar de emitir um valor a cada segundo (mais rapidamente que o timer, portanto), esses valores serão descartados</span>

Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
    .skipUntil(timer)
    .doOnNext(System.out::println)
    .subscribe();

Thread.sleep(<span class="hljs-number">10000</span>);

<span class="hljs-comment">/*
output:

5
6
7
8
9
*/</span>
</code></pre>
<h4>takeWhile e takeUntil</h4>
<p><img src="/images/programacao-reativa-parte-2-37.png" alt="takeWhile"></p>
<p>O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#takeWhile-io.reactivex.functions.Predicate-">takeWhile</a> tem uma semântica inversa ao <code>skipWhile</code>; esse operador também recebe um <code>Predicate</code> e retorna um <code>Observable</code> que <strong>captura</strong> os elementos emitidos <strong>enquanto a condição for verdadeira</strong>, descartando os demais a partir do primeiro elemento em que a condição é falsa:</p>
<pre class="highlight"><code class="hljs java">Observable.range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)
        .takeWhile(v -&gt; v &lt; <span class="hljs-number">5</span>) <span class="hljs-comment">//captura os elementos menores que 5</span>
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

0
1
2
3
4
*/</span>
</code></pre>
<p><img src="/images/programacao-reativa-parte-2-38.png" alt="takeUntil"></p>
<p>O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#takeUntil-io.reactivex.functions.Predicate-">takeUntil</a> recebe um <code>Predicate</code> e devolve um <code>Observable</code> que captura os elementos emitidos <strong>até que a condição seja satisfeita</strong>, e então emite o <em>onCompleted</em>:</p>
<pre class="highlight"><code class="hljs java">Observable.range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)
        .takeUntil(v -&gt; v &gt;= <span class="hljs-number">5</span>) <span class="hljs-comment">// captura todos menores ou iguais a 5; a partir do momento em que essa condição for satisfeita, os demais serão descartados</span>
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

0
1
2
3
4
5
*/</span>
</code></pre>
<p>Também existe uma <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#takeUntil-io.reactivex.ObservableSource-">sobrecarga</a> desse operador que funciona de maneira análoga ao <code>skipUntil</code> (recebendo um segundo <code>Observable</code>), mas tem um comportamento contrário: captura todos os elementos até que o segundo <code>Observable</code> emita algum valor:</p>
<pre class="highlight"><code class="hljs java">Observable&lt;Long&gt; timer = Observable.timer(<span class="hljs-number">5000</span>, TimeUnit.MILLISECONDS); <span class="hljs-comment">// emite um valor a cada 5 segundos</span>

<span class="hljs-comment">// o operador takeUntil criará um novo Observable que reemitirá os valores até o timer emitir algo, e depois completará</span>
<span class="hljs-comment">// o Observable abaixo emite valores mais rapidamente que o timer, mas emitirá apenas até o segundo Observable sinalizar</span>

Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
    .takeUntil(timer)
    .doOnNext(System.out::println)
    .doOnComplete(() -&gt; System.out.println(<span class="hljs-string">"Completed"</span>))
    .subscribe();

Thread.sleep(<span class="hljs-number">10000</span>);

<span class="hljs-comment">/*
output:

0
1
2
3
Completed
*/</span>
</code></pre>
<h4>ignoreElements</h4>
<p><img src="/images/programacao-reativa-parte-2-39.png" alt="ignoreElements"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#ignoreElements--">ignoreElements</a> ignora todos os itens emitidos, simulando um evento terminal. O retorno desse método um <code>Completable</code>:</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>)
        .ignoreElements()
        .doOnComplete(() -&gt; System.out.println(<span class="hljs-string">"OnComplete"</span>))
        .subscribe();

<span class="hljs-comment">/*
output:

OnComplete
*/</span>
</code></pre>
<h3>Condicionais</h3>
<h4>all e any</h4>
<p><img src="/images/programacao-reativa-parte-2-40.png" alt="all"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#all-io.reactivex.functions.Predicate-">all</a> devolve um <code>Single</code> do tipo <code>boolean</code>, indicando se <strong>todos</strong> os elementos emitidos atendem uma determinada condição. Já o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#any-io.reactivex.functions.Predicate-">any</a> verifica se <strong>algum</strong> elemento atende à condição:</p>
<pre class="highlight"><code class="hljs java">Observable.range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)
        .all(v -&gt; v &lt;= <span class="hljs-number">5</span>)
        .doOnSuccess(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

false
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>)
        .all(v -&gt; v % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
        .doOnSuccess(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

true
*/</span>
</code></pre>
<p><img src="/images/programacao-reativa-parte-2-41.png" alt="any"></p>
<pre class="highlight"><code class="hljs java">Observable.range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)
        .any(v -&gt; v &lt;= <span class="hljs-number">5</span>)
        .doOnSuccess(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

true
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>)
        .all(v -&gt; v % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)
        .doOnSuccess(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

false
*/</span>
</code></pre>
<h4>contains</h4>
<p><img src="/images/programacao-reativa-parte-2-42.png" alt="contains"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#contains-java.lang.Object-">contains</a> retorna um <code>Single</code> do tipo <code>boolean</code>, indicando se o <code>Observable</code> emitiu um item específico:</p>
<pre class="highlight"><code class="hljs java">Observable.range(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)
        .contains(<span class="hljs-number">2</span>)
        .doOnSuccess(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

true
*/</span>
</code></pre>
<pre class="highlight"><code class="hljs java">Observable.range(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)
        .contains(<span class="hljs-number">10</span>)
        .doOnSuccess(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

false
*/</span>
</code></pre>
<h3>Concatenação de streams</h3>
<p>Uma vez que a programação reativa tem no <code>stream</code> sua figura principal, sob o princípio de que &quot;tudo é um stream&quot; e todas as origens e sequências de dados podem ser representadas em um <code>stream</code>, é muito comum a necessidade de concatenarmos de alguma forma diferentes fluxos de dados. Existem vários operadores para esses casos de uso. Todos os operadores demonstrados abaixo permitem também a concatenação de <code>streams</code> de <strong>tipos diferentes</strong>, o que também é uma necessidade comum (um <code>Observable</code> de <code>Strings</code> ser concatenado a um <code>Observable</code> de números, por exemplo, gerando um novo <code>Observable</code> como resultado).</p>
<h4>concat</h4>
<p><img src="/images/programacao-reativa-parte-2-43.png" alt="concat"></p>
<p><a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#concat-java.lang.Iterable-">Existem</a> <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#concat-io.reactivex.ObservableSource-io.reactivex.ObservableSource-io.reactivex.ObservableSource-io.reactivex.ObservableSource-">vários</a> <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#concatArray-io.reactivex.ObservableSource...-">sabores</a> desse operador. A idéia básica da sua utilização é o formato de um método de fábrica estático que permite concatenar múltiplos <code>Observables</code> para gerar um novo.</p>
<pre class="highlight"><code class="hljs java">Observable&lt;String&gt; first = Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>);

Observable&lt;String&gt; second = Observable.just(<span class="hljs-string">"four"</span>, <span class="hljs-string">"five"</span>, <span class="hljs-string">"six"</span>);

Observable&lt;String&gt; third = Observable.just(<span class="hljs-string">"seven"</span>, <span class="hljs-string">"eight"</span>, <span class="hljs-string">"nine"</span>);

Observable.concat(first, second, third)
    .doOnNext(System.out::println)
    .subscribe();
</code></pre>
<p>Um ponto-chave dos vários métodos <code>concat</code> é que os <code>Observables</code> que funcionam como fontes de dados são drenados <em>na ordem em que foram enviados</em>, o que significa que o primeiro <code>stream</code> terá todos os seus valores coletados até emitir o <code>onCompleted</code>, e o processo será repetido com o <code>stream</code> seguinte, sucessivamente. Isso parece evidente nesse exemplo, mas nem sempre é o comportamento desejado. Mais abaixo vamos analisar operadores com semânticas diferentes.</p>
<p>Também existe o operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#concatMap-io.reactivex.functions.Function-">concatMap</a>, que permite transformar cada elemento em um <code>Observable</code>, e o retorno é um novo <code>Observable</code> que é gerado a partir da concatenação dos <code>streams</code> resultantes:</p>
<pre class="highlight"><code class="hljs java">Observable.range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)
        .concatMap(i -&gt; Observable.just(<span class="hljs-string">"hello, i'm the number "</span> + i)) <span class="hljs-comment">//o retorno será o resultado da concatenação dos Observables gerados por essa função</span>
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

hello, i'm the number 1
hello, i'm the number 2
hello, i'm the number 3
hello, i'm the number 4
hello, i'm the number 5
hello, i'm the number 6
hello, i'm the number 7
hello, i'm the number 8
hello, i'm the number 9
hello, i'm the number 10
*/</span>
</code></pre>
<h4>combineLatest</h4>
<p><img src="/images/programacao-reativa-parte-2-44.png" alt="combineLatest"></p>
<p>Um operador interessante é o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#combineLatest-java.lang.Iterable-io.reactivex.functions.Function-">combineLatest</a>, em suas diversas variações. A idéia desse método é gerar um <code>Observable</code> a partir dos <strong>últimos valores emitidos</strong> pelos <code>streams</code> utilizados como fontes de dados, conforme os itens são emitidos.
A função de concatenação recebe um <em>array</em> com todos os valores.</p>
<pre class="highlight"><code class="hljs java">Observable&lt;String&gt; first = Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>);

Observable&lt;String&gt; second = Observable.just(<span class="hljs-string">"four"</span>, <span class="hljs-string">"five"</span>, <span class="hljs-string">"six"</span>);

Observable&lt;String&gt; third = Observable.just(<span class="hljs-string">"seven"</span>, <span class="hljs-string">"eight"</span>, <span class="hljs-string">"nine"</span>);

<span class="hljs-comment">// a função de transformação irá receber os últimos valores emitidos como um array.</span>
<span class="hljs-comment">// nesse exemplo, temos três Observables de entrada. O array será gerado com último valor de cada um e apenas quando os três emitirem algum valor.</span>
<span class="hljs-comment">// a função de concatenação continuará sendo invocada até que todos terminem (no exemplo abaixo, a "concatenação" é o toString sobre o array).</span>

Observable.combineLatest(Arrays.asList(first, second, third), Arrays::toString)
    .doOnNext(System.out::println)
    .subscribe();

<span class="hljs-comment">/*
output:

[three, six, seven]
[three, six, eight]
[three, six, nine]
*/</span>
</code></pre>
<p>Uma sobrecarga desse método permite passar vários <code>Observables</code> e uma função que recebe cada valor individual, ao invés de um <em>array</em>:</p>
<pre class="highlight"><code class="hljs java">Observable.combineLatest(first, second, third, (a, b, c) -&gt; a + <span class="hljs-string">"-"</span> + b + <span class="hljs-string">"-"</span> + c)
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

three-six-seven
three-six-eight
three-six-nine
*/</span>
</code></pre>
<p>Um método de instância do <code>Observable</code> que tem um comportamento parecido é o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#withLatestFrom-java.lang.Iterable-io.reactivex.functions.Function-">withLatestFrom</a>, que gera um novo <code>Observable</code> com os valores emitidos pelo <code>stream</code> combinados com o último valor emitido por um segundo <code>Observable</code> (a lógica de combinação é representada em uma função).</p>
<h4>merge</h4>
<p><img src="/images/programacao-reativa-parte-2-45.png" alt="merge"></p>
<p>Outra maneira de concatenar <code>Observables</code> é o operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#merge-java.lang.Iterable-">merge</a>, que funciona de maneira equivalente ao <code>concat</code>, mas gera um novo <code>Observable</code> com os itens dos <code>streams</code> de origem <strong>conforme eles são emitidos</strong>, independente da ordem em que foram enviados.</p>
<pre class="highlight"><code class="hljs java">Observable&lt;String&gt; first = Observable.interval(<span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS)
        .map(v -&gt; <span class="hljs-string">"First observable: "</span> + v)
        .take(<span class="hljs-number">5</span>);

Observable&lt;String&gt; second = Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
        .map(v -&gt; <span class="hljs-string">"Second observable: "</span> + v)
        .take(<span class="hljs-number">5</span>);

Observable&lt;String&gt; third = Observable.interval(<span class="hljs-number">500</span>, TimeUnit.MILLISECONDS)
        .map(v -&gt; <span class="hljs-string">"Third observable: "</span> + v)
        .take(<span class="hljs-number">5</span>);

Observable.merge(first, second, third)
    .doOnNext(System.out::println)
    .subscribe();

Thread.sleep(<span class="hljs-number">10000</span>);

<span class="hljs-comment">/*
output:

Third observable: 0
Second observable: 0
Third observable: 1
Third observable: 2
Second observable: 1
First observable: 0
Third observable: 3
Third observable: 4
Second observable: 2
Second observable: 3
First observable: 1
Second observable: 4
First observable: 2
First observable: 3
First observable: 4
*/</span>
</code></pre>
<p>Novamente, a diferença de destaque entre este operador e o <code>concat</code> é que o <code>merge</code> não aguarda um <code>Observable</code> de entrada ser completado para drenar o próximo. Utilize o <code>concat</code> caso precise manter a ordem de emissão dos <code>streams</code> de origem.</p>
<p>Embora o <code>merge</code> também seja um método estático (de fábrica), também é possível realizar essa operação em um <code>Observable</code> já existente, usando o método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#mergeWith-io.reactivex.ObservableSource-">mergeWith</a>. O comportamento é o mesmo, de modo que o novo <code>Observable</code> reemitirá os valores conforme são emitidos nos <code>streams</code> de origem:</p>
<pre class="highlight"><code class="hljs java">Observable.interval(<span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS)
        .map(v -&gt; <span class="hljs-string">"Source observable: "</span> + v)
        .mergeWith(
                Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
                    .map(v -&gt; <span class="hljs-string">"Merged observable: "</span> + v)
        )
        .doOnNext(System.out::println)
        .subscribe();

<span class="hljs-comment">/*
output:

Merged observable: 0
Source observable: 0
Merged observable: 1
Merged observable: 2
Merged observable: 3
Source observable: 1
Merged observable: 4
Merged observable: 5
Source observable: 2
Merged observable: 6
Merged observable: 7
Source observable: 3
Merged observable: 8
Merged observable: 9
Source observable: 4
*/</span>
</code></pre>
<h4>zip</h4>
<p><img src="/images/programacao-reativa-parte-2-46.png" alt="zip"></p>
<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#zip-java.lang.Iterable-io.reactivex.functions.Function-">zip</a> representa uma operação comum em linguagens funcionais. Esse operador irá concatenar os elementos de <em>n</em> <code>Observables</code> usando uma função de transformação, agrupando os items pelo <strong>índice</strong>. Ou seja, o novo <code>Observable</code> irá emitir primeiro o retorno da função aplicada ao primeiro item de cada <code>stream</code> de entrada; o segundo elemento emitido será o retorno da função aplicada ao segundo item de cada <code>stream</code>, e assim sucessivamente.</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-comment">// nesse exemplo, temos três Observables que emitem valores em intervalos diferentes, e vamos concatena-los usando o zip.</span>
<span class="hljs-comment">// O Observable gerado irá aguardar os três streams de entrada emitirem valores,</span>
<span class="hljs-comment">// pois a agregação do zip é realizada usando o índice do elemento emitido.</span>

Observable&lt;Long&gt; first = Observable.interval(<span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS);

Observable&lt;Long&gt; second = Observable.interval(<span class="hljs-number">500</span>, TimeUnit.MILLISECONDS);

Observable&lt;Long&gt; third = Observable.interval(<span class="hljs-number">500</span>, TimeUnit.MILLISECONDS);

Observable.zip(first, second, third, (a, b, c) -&gt; a + <span class="hljs-string">" - "</span> + b + <span class="hljs-string">" - "</span> + c)
        .doOnNext(System.out::println)
        .subscribe();

Thread.sleep(<span class="hljs-number">10000</span>);

<span class="hljs-comment">/*
output:

0 - 0 - 0
1 - 1 - 1
2 - 2 - 2
3 - 3 - 3
4 - 4 - 4
*/</span>
</code></pre>
<p>O método de instância equivalente é o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#zipWith-java.lang.Iterable-io.reactivex.functions.BiFunction-">zipWith</a>, que tem o mesmo comportamento.</p>
<pre class="highlight"><code class="hljs java">Observable.just(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>)
        .zipWith(Observable.interval(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS), (a, b) -&gt; a + <span class="hljs-string">" - "</span> + b)
        .doOnNext(System.out::println)
        .subscribe();

Thread.sleep(<span class="hljs-number">5000</span>);

<span class="hljs-comment">/*
output:

one - 0
two - 1
three - 2
*/</span>
</code></pre>
<h4>amb</h4>
<p><img src="/images/programacao-reativa-parte-2-47.png" alt="amb"></p>
<p>Outro operador de concatenação é o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#amb-java.lang.Iterable-">amb</a>, que gera um <code>Observable</code> que, dados múltiplos <code>streams</code> de entrada, reemite o primeiro elemento do <strong>primeiro Observable que emitir algum valor</strong>, completando a seguir. Os demais <code>Observables</code> são descartados.</p>
<pre class="highlight"><code class="hljs java">Observable&lt;String&gt; fast = Observable.timer(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
        .map(v -&gt; <span class="hljs-string">"First observable: "</span> + v)
        .take(<span class="hljs-number">5</span>);

Observable&lt;String&gt; slow = Observable.timer(<span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS)
        .map(v -&gt; <span class="hljs-string">"Second observable: "</span> + v)
        .take(<span class="hljs-number">5</span>);

Observable.amb(Arrays.asList(fast, slow))
        .doOnNext(System.out::println)
        .doOnComplete(() -&gt; System.out.println(<span class="hljs-string">"OnComplete"</span>))
        .subscribe();

Thread.sleep(<span class="hljs-number">3000</span>);

<span class="hljs-comment">/*
output:

First observable: 0
OnComplete
*/</span>
</code></pre>
<p>O método de instância equivalente é o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#ambWith-io.reactivex.ObservableSource-">ambWith</a>, que tem o mesmo comportamento:</p>
<pre class="highlight"><code class="hljs java">Observable.timer(<span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS)
        .map(v -&gt; <span class="hljs-string">"First observable: "</span> + v)
        .ambWith(
            Observable.timer(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS) <span class="hljs-comment">// o segundo Observable emite valores mais rapidamente</span>
                    .map(v -&gt; <span class="hljs-string">"Second observable: "</span> + v)
        )
        .take(<span class="hljs-number">5</span>)
        .doOnNext(System.out::println)
        .doOnComplete(() -&gt; System.out.println(<span class="hljs-string">"OnComplete"</span>))
        .subscribe();

<span class="hljs-comment">/*
output:

Second observable: 0
OnComplete
*/</span>
</code></pre>
<p>Esse operador, embora talvez não pareça a primeira vista, é extremamente útil. Imagine que você precise ler múltiplas fontes de dados, como diversos servidores onde uma informação poderia estar, e quer utilizar a resposta mais rápida; o <code>amb</code> fará exatamente isso para você. Um código que seria complicado se torna trivial com o uso do <code>amb</code>.</p>
<h2>Conclusão</h2>
<p>Ufa! E pensar que ainda faltaram muitos métodos...mas para este capítulo da nossa jornada reativa é o suficiente. Nesse post, vimos em detalhes o principal objeto dos frameworks Rx, o <code>Observable</code>, e seus irmãos <code>Completable</code>, <code>Single</code> e <code>Maybe</code>. Também olhamos os objetos do tipo <code>Subject</code>, que são muito úteis em várias situações e bastante utilizados no ecossistema Rx.</p>
<p>Nesse post também vimos em detalhes o verdadeiro poder dessas bibliotecas: os <strong>operadores reativos</strong>, um espetacular conjunto de métodos que tornam tarefas que seriam complicadas quase triviais. E todos esses operadores têm em comum a construção do <code>stream</code> como um <strong>fluxo de dados</strong>, em que as modificações dos dados são <strong>propagadas</strong>, em oposição ao modelo de mudança de estado. Isso facilita sobremaneira o modelo de programação, onde podemos nos basear em funções declarativas e livres de efeitos colaterais. Isso nos dá outros benefícios que iremos explorar no próximo post, onde falaremos sobre <strong>paralelismo</strong>, <strong>programação concorrente</strong> e <strong>contrapressão</strong>.</p>
<p>Apesar do post loooongo, espero que tenha gostado e que seja útil para você na utilização do RxJava! Em caso de dúvidas, críticas ou qualquer outra coisa, sinta-se livre para utilizar a caixa de comentários!</p>


		<ul class='tag-list'>
		
			<li>
				<a href='/tags/java/'>java</a>
			</li>
		
			<li>
				<a href='/tags/programacao-reativa/'>programacao-reativa</a>
			</li>
		
		</ul>
		<section class='share'>
			<a href='#share' class='share-post hide' title='Clique aqui para compartilhar esse post'>Compartilhe</a>
			<div class='social-share'>
				<a href='https://www.facebook.com/dialog/share?app_id=644444999041914&href=https://engenharia.elo7.com.br/programacao-reativa-parte-2/&display=popup' rel='noopener' target='_blank' class='link-share facebook' title='Clique para compartilhar no Facebook'>
					Compartilhar no facebook
				</a>
				<a href='https://twitter.com/intent/tweet?text=Programação Reativa - Parte 2&url=https://engenharia.elo7.com.br/programacao-reativa-parte-2/&hashtags=elo7tech' rel='noopener' target='_blank' class='link-share twitter' title='Clique para compartilhar no Twitter'>
					Compartilhar no twitter
				</a>
				<a href='https://engenharia.elo7.com.br/programacao-reativa-parte-2/?utm_source=share&utm_medium=copy' class='link-share hide copy' title='Clique para copiar a url'>
					Copiar URL
				</a>
				<span class='copy-success'>Link copiado</span>
				<input type='url' value='https://engenharia.elo7.com.br/programacao-reativa-parte-2/?utm_source=share&utm_medium=copy' class='link-input'>
			</div>
		</section>
	</div>
	<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"> <!--Change for a post image-->
		<link href="/images/ico/elo7.png" itemprop="url"/>
		<meta itemprop='width' content='100px'/>
		<meta itemprop='height' content='100px'/>
	</span>

	<meta itemprop='headline' content='Continuando a série sobre Programação Reativa, agora com um pouco de código!'/>
	<span itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
		<meta itemprop='name' content='Elo7 Tech'/>
		<meta itemprop="url" content='https://engenharia.elo7.com.br'/>
		<span itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
			<link href="https://images.elo7.com.br/assets/v3/desktop/png/logo-elo7.png" itemprop="url"/>
			<meta itemprop='width' content='100px'/>
			<meta itemprop='height' content='100px'/>
		</span>
	</span>
	<meta itemprop='mainEntityOfPage' content='Elo7 Serviços de Informática SA'/>

	<div id='disqus_thread'></div>

	<script>
		var disqus_shortname = 'engenhariaelo7';
		var disqus_identifier = '21/05/2018:/programacao-reativa-parte-2/';
		var disqus_url = 'https://engenharia.elo7.com.br/programacao-reativa-parte-2/';

		(function() {
			var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
			dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
			(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
		})();
	</script>
	<noscript>Habilite o JavaScript para ver os comentários</noscript>
</article>
<script async src="/js/post.js"></script>

		
	</main>
	<footer itemscope itemtype="http://schema.org/Organization">
		<a rel="home" itemprop="url" href="https://engenharia.elo7.com.br/" >
			engenharia.elo7.com.br © 2017
		</a>
		<meta itemprop="name" content="Elo7 Serviços de Informática SA"/>
		<section class='footer-social'>
			<a title='Github do Elo7' rel='external' itemprop='url' href='https://github.com/elo7' target='_blank' class='github'>Github do Elo7</a>
			<a title='Twitter do Elo7' rel='external' itemprop='url' href='https://twitter.com/elo7tech' target='_blank' class='twitter'>Twitter do Elo7</a>
			<a title='RSS do Elo7' rel='external' itemprop='url' href='https://engenharia.elo7.com.br/rss.xml' target='_blank' class='rss'>RSS do Elo7</a>
			<a title='Newsletter do Elo7' rel='external' itemprop='url' href='http://eepurl.com/cVUwvH' target='_blank' class='email'>Newsletter do Elo7</a>
		</section>
	</footer>
	<script async src="https://www.google-analytics.com/analytics.js"></script>
	<script async src="/js/analytics.js"></script>
	<script async src="/js/github.js"></script>
	<script async src="/js/vendor/events-amd.js"></script>
	<script async src="/js/vendor/ajax.js"></script>
	<script async src="/js/vendor/doc.js"></script>
	<script async type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
