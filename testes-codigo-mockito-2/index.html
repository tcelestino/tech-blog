<!doctype html>
<html lang="pt-br">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Há algum tempo, escrevi sobre o funcionamento e os principais recursos do Mockito. Neste post, vamos conhecer as novidades da nova versão do framework.">
	<meta name="google-site-verification" content="NqCILBTY8B8P-r_KF8BSZKH9kUQgQOEbXJvEMaB33vw">
	<meta name="google-site-verification" content="cKh-stJM3_ENNfMjaBIIyYiDgMXZFpRkoH8eQTcPwhM" />
	<meta name="theme-color" content="#FDC24F">
	<meta name="keywords" content="Elo7,tecnologia,post,desenvolvimento,blog,java,mockito,tdd">
	<meta name="language" content="pt-br">
	<meta name="title" content="Elo7 Tech - Testes de código com Mockito (2) - Novidades da nova versão">
	<meta name="apple-mobile-web-app-title" content="Elo7 Tech - Testes de código com Mockito (2) - Novidades da nova versão">
	<meta name="mobile-web-app-capable" content="yes">

	<meta property="fb:app_id" content="644444999041914">
	<meta property="fb:admins" content="100003324447975">

	<meta property="og:site_name" content="Elo7 Tech">
	<meta property="og:image" content="https://engenharia.elo7.com.br/images/ico/elo7.png">
	<meta property="og:type" content="website">
	<meta property="og:title" content="Elo7 Tech - Testes de código com Mockito (2) - Novidades da nova versão">
	<meta property="og:url" content="https://engenharia.elo7.com.br/testes-codigo-mockito-2/">
	<meta property="og:description" content="Há algum tempo, escrevi sobre o funcionamento e os principais recursos do Mockito. Neste post, vamos conhecer as novidades da nova versão do framework.">

	<meta name="twitter:widgets:csp" content="on">
	<meta name="twitter:card" content="summary_large_image">

	<meta property="twitter:title" content="Elo7 Tech - Testes de código com Mockito (2) - Novidades da nova versão">
	<meta property="twitter:domain" content="https://engenharia.elo7.com.br">
	<meta property="twitter:url" content="https://engenharia.elo7.com.br/testes-codigo-mockito-2/">
	<meta property="twitter:description" content="Há algum tempo, escrevi sobre o funcionamento e os principais recursos do Mockito. Neste post, vamos conhecer as novidades da nova versão do framework.">
	<meta property="twitter:image" content="https://engenharia.elo7.com.br/images/ico/elo7.png">

	<link rel="canonical" href="https://engenharia.elo7.com.br/testes-codigo-mockito-2/">
	
		<link rel='amphtml' href='https://engenharia.elo7.com.br/amp/testes-codigo-mockito-2/' />
	

	<title>Elo7 Tech - Testes de código com Mockito (2) - Novidades da nova versão</title>
	<link rel="stylesheet" href="/reset.css">
	<link rel="stylesheet" href="/main.css">
	<link rel="stylesheet" href="/posts.css">
	<link rel="stylesheet" href="/post.css">
	<link rel="icon" href="/images/favicon/favicon-16.png" sizes="16x16">
	<link rel="icon" href="/images/favicon/favicon-32.png" sizes="32x32">
	<link rel="icon" href="/images/favicon/favicon-48.png" sizes="48x48">
	<link rel="icon" href="/images/favicon/favicon-64.png" sizes="64x64">
	<link rel="icon" href="/images/favicon/favicon-96.png" sizes="96x96">
	<link rel="icon" href="/images/favicon/favicon-128.png" sizes="128x128">
	<link rel="icon" href="/images/favicon/favicon-160.png" sizes="160x160">
	<link rel="icon" href="/images/favicon/favicon-192.png" sizes="192x192">
	<link rel="apple-touch-icon-precomposed" sizes="180x180" href="/images/favicon/favicon-180.png">
	<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/images/favicon/favicon-152.png">
	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/favicon/favicon-144.png">
	<link rel="apple-touch-icon-precomposed" sizes="120x120" href="/images/favicon/favicon-120.png">
	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/images/favicon/favicon-114.png">
	<link rel="apple-touch-icon-precomposed" sizes="76x76" href="/images/favicon/favicon-76.png">
	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/favicon/favicon-72.png">
	<link rel="apple-touch-icon-precomposed" sizes="60x60" href="/images/favicon/favicon-60.png">
	<link rel="apple-touch-icon-precomposed" sizes="57x57" href="/images/favicon/favicon-57.png">
	<link rel="apple-touch-icon-precomposed" href="/images/favicon/favicon-precomposed.png">
	<script>window.addEventListener("error", window.__e=function f(e){f.q=f.q||[];f.q.push(e)});</script>
	<script src="/js/vendor/async-define.js"></script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" data-env="production" data-ga-code="UA-3692628-29">
	<header class="left-pane">
		<div class="logo-container">
			<a rel="home" itemprop="url" href="/" class="logo">Tech Blog Elo7</a>
		</div>
		<div itemscope itemtype="http://schema.org/SiteNavigationElement" class="navigation">
			<input id="categories-switch" type="checkbox" class="categories-switch">
			<label for="categories-switch" class="selectable">
				<h2 class="nav-title">Categorias</h2>
			</label>
			<nav aria-label="Navegue pelas categorias do nosso blog" class="nav-list nav-category">
				
					<a itemprop="url" href="/back-end/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Back-end</span>
					</a>
				
					<a itemprop="url" href="/cultura/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Cultura</span>
					</a>
				
					<a itemprop="url" href="/data-science/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Data Science</span>
					</a>
				
					<a itemprop="url" href="/design/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Design</span>
					</a>
				
					<a itemprop="url" href="/devops/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Devops</span>
					</a>
				
					<a itemprop="url" href="/eventos/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Eventos</span>
					</a>
				
					<a itemprop="url" href="/front-end/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Front-end</span>
					</a>
				
					<a itemprop="url" href="/mobile/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Mobile</span>
					</a>
				
					<a itemprop="url" href="/vagas/" itemscope itemtype="http://schema.org/SiteNavigationElement">
						<span itemprop="name">Vagas</span>
					</a>
				
			</nav>
		</div>
		<div class="navigation">
			<input id="more-switch" type="checkbox" class="more-switch">
			<label for="more-switch" class="selectable">
				<h2 class="nav-title">Veja também</h2>
			</label>
			<nav class="nav-list nav-more" aria-label="Navegue pelos links relacionados ao Elo7">
				<a itemscope itemtype="http://schema.org/SiteNavigationElement" itemprop="url" href="http://carreira.elo7.com.br/engenharia/" target="_blank">
					<span itemprop="name">A engenharia</span>
				</a>
				<a itemscope itemtype="http://schema.org/SiteNavigationElement" itemprop="url" href="http://carreira.elo7.com.br/" target="_blank">
					<span itemprop="name">Carreiras</span>
				</a>
				<a itemscope itemtype="http://schema.org/SiteNavigationElement" itemprop="url" href="http://eventos.elo7.com.br/" target="_blank">
					<span itemprop="name">Nossos eventos</span>
				</a>
				<a itemscope itemtype="http://schema.org/SiteNavigationElement" itemprop="url" href="http://elo7.com.br/" target="_blank">
					<span itemprop="name">Elo7</span>
				</a>
			</nav>
		</div>
		<div class='social'>
			<a title="Github do Elo7" rel="external" itemprop="url" href="https://github.com/elo7" target="_blank" class="github">Github do Elo7</a>
			<a title="Twitter do Elo7" rel="external" itemprop="url" href="https://twitter.com/elo7tech" target="_blank" class="twitter">Twitter do Elo7</a>
			<a title='RSS do Elo7' rel="external" itemprop="url" href="https://engenharia.elo7.com.br/rss.xml" target="_blank" class="rss">RSS do Elo7</a>
			<a title='Newsletter do Elo7' rel="external" itemprop="url" href="http://eepurl.com/cVUwvH" target="_blank" class="email">Newsletter do Elo7</a>
		</div>
	</header>
	<main aria-label="Main content" itemscope itemtype="http://schema.org/Blog">
		<article itemprop='blogPost' itemscope itemtype='http://schema.org/BlogPosting' class='post-content'>
	<h1 itemprop='name' class='title'>Testes de código com Mockito (2) - Novidades da nova versão</h1>
	<div class='post-meta'>
		<p class='date'>
			Publicado em: <time datetime='21/08/2017' itemprop='datePublished'>21/08/2017</time>
			<meta itemprop='dateModified' content='21/08/2017'>
		</p>

		<article>
			
				<a data-author='ljtfreitas' itemprop='author' itemscope itemtype='http://schema.org/Person' rel='author' href='/ljtfreitas/' class='author'>
					<meta itemprop='url' content='/ljtfreitas'>
					<img class='hide avatar' width='50px' height='50px' itemprop='image'>
					<p itemprop='name' class='publisher' data-author='ljtfreitas'>@ljtfreitas</p>
				</a>
			

			<meta itemprop='worksFor' content='Elo7 Serviços de Informática SA'>
		</article>
	</div>
	<div itemprop='articleBody'>
		<p>Há algum tempo, escrevi um <a href="/testes-codigo-mockito">post</a> sobre o funcionamento e os principais recursos do <a href="http://site.mockito.org/">Mockito</a>. Na ocasião em que o post foi escrito, a versão 2 do framework ainda estava em beta, e, nesse tempo, não apenas foi <a href="https://github.com/mockito/mockito/wiki/What%27s-new-in-Mockito-2">oficialmente lançada</a> como ocorreram vários releases subsequentes (no momento em que escrevo, a última versão é a 2.7.22).</p>
<p>Neste post, vou demonstrar as principais novidades e funcionalidades dessa nova versão.</p>
<h2>Construção de mocks/proxy de objetos e classes final</h2>
<p>A principal alteração interna da versão 2 do Mockito foi a mudança da biblioteca utilizada para construção de mocks/proxificação de objetos. Para entendermos melhor essa mudança, cabe perguntar: o que raios é um proxy?</p>
<p>Sem me estender muito na explicação, &quot;proxy&quot; é um design pattern que permite colocar um objeto &quot;espelho&quot; à frente de outro, que implemente a mesma interface (interface = conjunto de métodos expostos do objeto). Esse objeto &quot;espelho&quot; (que é a instância efetivamente usada no código, funcionando como um substituto ao objeto real) é capaz de interceptar as chamadas de método realizadas, capturando os metadados do método invocado e os argumentos enviados. O proxy é capaz de realizar tratamentos específicos para algum método em particular, ou manipular os argumentos antes de invocar o método no objeto &quot;verdadeiro&quot;, e eventualmente até mesmo cancelar a invocação. Normalmente, isso é implementado utilizando algum recurso fornecido pela própria linguagem.</p>
<p>No caso do Java, proxys são um elemento fundamental em frameworks de mock. TODOS os mocks gerados pelo Mockito são proxies da classe que está sendo &quot;mockada&quot;. No meu primeiro post, eu disse que uma definição fundamental da palavra &quot;mock&quot; é que se trata de um <strong>objeto gerado em tempo de execução</strong>; em Java, isso ocorre literalmente, porque um proxy é, com efeito, bytecode gerado em tempo de execução :).</p>
<p>A API padrão do Java permite a geração de proxies <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html#getProxyClass">apenas para interfaces</a>; essa limitação era contornada com o uso de algumas coisas complicadas como instrumentação de código, manipulação de bytecode e compilação em runtime. As bibliotecas que se destacam na comunidade Java para esse tipo de trabalho são o <a href="https://github.com/cglib/cglib">CGLIB</a> e o <a href="https://github.com/jboss-javassist/javassist">javassist</a>, utilizados em vários frameworks (como o Spring e o Hibernate).</p>
<p>O Mockito, desde a primeira versão, usava o CGLIB como ferramenta de construção de mocks; a partir da versão 2, a biblioteca utilizada passou a ser o <a href="http://bytebuddy.net/">ByteBuddy</a>. As principais justificativas para a mudança são que o CGLIB, de fato, tem algumas limitações em relação ao bytecode gerado nas versões mais recentes do Java, além do ByteBuddy permitir a correção de alguns bugs de longa data do Mockito (que não eram passíveis de correções por limitações do CGLIB).</p>
<p>Mas, apesar de realmente ser uma mudança de alto impacto, o que isso muda para os nossos testes? A princípio, nada. Como a construção de mocks/proxies de objetos é feita internamente pelo Mockito, a maneira como os mocks são gerados não tem nenhum efeito direto sobre como nossos testes são escritos. Não obstante, essa mudança teve o efeito positivo de introduzir uma novidade, ainda que em caráter experimental: permitir mockar classes <em>final</em>! :)</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">bla</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"bla"</span>;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleTest</span> </span>{

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        Sample sampleMock = Mockito.mock(Sample.class);
        when(sampleMock.bla()).thenReturn(<span class="hljs-string">"foo"</span>);

        String output = sampleMock.bla();

        assertEquals(<span class="hljs-string">"foo"</span>, output);
    }
}
</code></pre>
<p>Nas versões 1.x do Mockito, o teste acima simplesmente não funcionaria, pois seria impossível mockar a classe Sample ou mesmo o método &quot;bla()&quot;. Isto porquê o mecanismo de proxy do CGLIB se baseia em criar, em tempo de execução, uma subclasse do objeto proxificado; como não é possível criar uma subclasse de uma classe <em>final</em>, ou sobrescrever um método marcado como <em>final</em>, não era possível implementar um teste como o do exemplo acima apenas com o Mockito. Para contornar essa limitação, uma biblioteca muito utilizada é o <a href="http://powermock.github.io/">PowerMock</a> (com a extensão <a href="http://www.javadoc.io/doc/org.powermock/powermock-api-mockito/1.6.4">PowerMockito</a>), que tem como premissa &quot;testar o não-testável&quot;, incluindo <a href="https://github.com/powermock/powermock/wiki/mockfinal">classes e métodos final</a> como no exemplo.</p>
<p>Como dito antes, o mock de classes/métodos <em>final</em> está em fase de testes no Mockito. Para habilitá-la, você deve ativar um mecanismo semelhante ao <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html">ServiceLoader</a> do Java:</p>
<ul>
<li>no seu classpath de teste, crie uma pasta chamada mockito-extensions, e dentro dela um arquivo chamado org.mockito.plugins.MockMaker (se o seu projeto utiliza Maven ou Gradle, por exemplo, o local desse arquivo seria &quot;src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker&quot;)</li>
<li>o conteúdo desse arquivo deve ser uma única linha contendo: <strong>mock-maker-inline</strong></li>
</ul>
<p>A presença desse arquivo irá sobrescrever o <a href="http://static.javadoc.io/org.mockito/mockito-core/2.7.22/org/mockito/plugins/MockMaker.html">MockMaker</a> padrão utilizado pelo Mockito. Essa interface foi projetada para servir como um ponto de extensão do framework, permitindo customizar a maneira como os mocks são criados.</p>
<p>Com a configuração acima, o Mockito irá utilizar uma implementação especialmente projetada para usar uma combinação de subclasses e instrumentação (através de um Java Agent). Mas não se preocupe: essas complexidades de baixo nível são invisíveis para o teste, e finalmente seremos capazes de mockar nossas classes e métodos <em>final</em> (como o exemplo acima) sem recorrer a outras bibliotecas!</p>
<p>Uma maneira simplificada de utilizar esse recurso é incluir a dependência <em>mockito-inline</em> no seu classpath. Esse artefato irá configurar o arquivo org.mockito.plugins.MockMaker como demonstrado acima.</p>
<p>Para mais detalhes: <a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html#Mocking_Final">Mock the unmockable</a></p>
<h2>Stubs não utilizados</h2>
<p>Um dos objetivos da nova versão do Mockito é ajudar os desenvolvedores a escrever testes melhores. Um dos pontos de atenção para manter os testes limpos e fáceis de entender é evitar código não utilizado, como configurações de mocks que não são usados na execução do programa. Vejamos um exemplo:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dictionary</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Translator translator;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dictionary</span><span class="hljs-params">(Translator translator)</span> </span>{
        <span class="hljs-keyword">this</span>.translator = translator;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String word)</span> </span>{
        <span class="hljs-keyword">return</span> translator.translate(word);
    }
}
</code></pre>
<p>E nosso teste:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-meta">@RunWith</span>(MockitoJUnitRunner.class)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictionaryTest</span> </span>{

    <span class="hljs-meta">@Mock</span>
    <span class="hljs-keyword">private</span> Translator translator;

    <span class="hljs-meta">@InjectMocks</span>
    <span class="hljs-keyword">private</span> Dictionary dictionary;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        String word = <span class="hljs-string">"ola"</span>;

        when(translator.translate(word)).thenReturn(<span class="hljs-string">"hello"</span>);

        String output = dictionary.get(word);

        assertNotNull(output);
    }
}
</code></pre>
<p>Nossa classe Dictionary, no método &quot;get&quot;, utiliza uma instância do Translator (uma interface; a implementação do Translator não é relevante para nós) para &quot;traduzir&quot; a palavra enviada como parâmetro. Utilizamos o Mockito para configurar o método &quot;translate&quot; do Translator, para devolver a String &quot;hello&quot; quando o método for invocado com a palavra &quot;word&quot;. O teste apenas verifica se a resposta do método é não-nula (um teste frágil mas atende nosso exemplo por hora). O teste acima passaria sem problema. Mas, e se nosso código fosse modificado da seguinte forma:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dictionary</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Translator translator;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dictionary</span><span class="hljs-params">(Translator translator)</span> </span>{
        <span class="hljs-keyword">this</span>.translator = translator;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String word)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"ooops"</span>;
    }
}
</code></pre>
<p>Perceba que o método &quot;get&quot; não utiliza mais o Translator. Este seria um bug que nosso teste não detectaria, por dois motivos: 1) o teste apenas confirma que a saída do método é uma String não-nula, o que continua acontecendo, e 2) o teste não verifica se o mock foi efetivamente invocado (usando o Mockito.verify). O ponto que quero ressaltar aqui é que a detecção do bug, nesse caso, <strong>depende do teste estar bem escrito</strong>. Isso pode parecer apenas senso comum, mas é muito fácil deixar passar esse tipo de detalhe, às vezes por simples desatenção momentânea, por não realizarmos completamente o ciclo do TDD (red-green-refactor), ou por desconhecimento de eventuais recursos dos frameworks envolvidos.</p>
<p>Por outro lado, a mudança que realizamos acima também poderia ser uma refatoração válida: digamos que nosso Dictionary realmente não irá mais utilizar o Translator e irá implementar sua lógica interna de outro modo. Em nosso teste, teríamos um mock não utilizado, com a configuração desnecessária poluindo o código. Agora, o Mockito é capaz de detectar esse tipo de situação.</p>
<p>Se executarmos novamente nosso DictionaryTest (após a mudança acima na classe Dictionary), teríamos como saída do teste:</p>
<p><img src="../images/testes-codigo-mockito-2-1.png" alt="mockito-2-output-unused-stub"></p>
<p>O teste irá passar, mas será exibido no relatório do Junit a seguinte mensagem:</p>
<pre class="highlight"><code class="hljs undefined">org.mockito.exceptions.misusing.UnnecessaryStubbingException:
Unnecessary stubbings detected in test class: DictionaryTest
Clean &amp; maintainable test code requires zero unnecessary code.
Following stubbings are unnecessary (click to navigate to relevant line of code):
  1. -&gt; at com.elo7.mockito.sample.DictionaryTest.test(DictionaryTest.java:25)
Please remove unnecessary stubbings or use 'silent' option. More info: javadoc for UnnecessaryStubbingException class.
    at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:49)
    at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:161)
    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)

</code></pre>
<p>Além da mensagem bastante explicativa, o erro também inclui a linha da classe com a configuração desnecessária do mock. Reforçando: essa mensagem de &quot;stubs não utilizados&quot; será exibida <strong>apenas se o teste passar</strong> (essa decisão foi justificada pela equipe do Mockito tendo em mente que, se o teste falhar, exibir a mensagem de falha em conjunto com o erro relativo aos stubs poderia gerar confusão ao usuário).</p>
<p>Então, agora temos o recurso do Mockito para nos ajudar a limpar o código de teste (se for o caso), indicando configurações de mocks (os tais &quot;stubs&quot;) não utilizados. Mas e se o teste ainda não estiver passando? Um problema em potencial poderia ser uma eventual configuração incorreta do mock; ou seja, o mock está sendo utilizado no código mas não da maneira como foi &quot;stubado&quot;. Digamos, algo assim:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dictionary</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Translator translator;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dictionary</span><span class="hljs-params">(Translator translator)</span> </span>{
        <span class="hljs-keyword">this</span>.translator = translator;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String word)</span> </span>{
        <span class="hljs-keyword">return</span> translator.translate(word);
    }
}
</code></pre>
<p>Novamente, nosso teste:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-meta">@RunWith</span>(MockitoJUnitRunner.class)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictionaryTest</span> </span>{

    <span class="hljs-meta">@Mock</span>
    <span class="hljs-keyword">private</span> Translator translator;

    <span class="hljs-meta">@InjectMocks</span>
    <span class="hljs-keyword">private</span> Dictionary dictionary;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        String word = <span class="hljs-string">"ola"</span>;

        when(translator.translate(word)).thenReturn(<span class="hljs-string">"hello"</span>);

        String output = dictionary.get(<span class="hljs-string">"oi"</span>);

        assertNotNull(output);
    }
}
</code></pre>
<p>O teste acima irá falhar. A resposta do método &quot;get&quot; do Dictionary será <em>null</em>, porque configuramos o Translator para devolver &quot;hello&quot; <strong>somente</strong> quando o método &quot;translate&quot; for invocado com o parâmetro &quot;ola&quot;, o que não foi o caso já que enviamos a String &quot;oi&quot;. O Mockito 2 também é capaz de nos auxiliar nessa situação, indicando que o mock foi utilizado, mas não da maneira como foi configurado. Ao rodar o teste acima, a seguinte mensagem será exibida no console:</p>
<pre class="highlight"><code class="hljs java">[MockitoHint] DictionaryTest.test (see javadoc <span class="hljs-keyword">for</span> MockitoHint):
[MockitoHint] <span class="hljs-number">1</span>. Unused... -&gt; at com.elo7.mockito.sample.DictionaryTest.test(DictionaryTest.java:<span class="hljs-number">25</span>)
[MockitoHint]  ...args ok? -&gt; at com.elo7.mockito.sample.Dictionary.get(Dictionary.java:<span class="hljs-number">12</span>)
</code></pre>
<p>Nessa mensagem, o Mockito incluiu o ponto do código onde o mock é configurado, e o ponto onde está sendo utilizado (incorretamente ou, no mínimo, de modo diferente do que foi configurado). Esse relatório é extremamente útil, principalmente para testes mais complexos (casos em que os programadores, invariavelmente, debugam o código para encontrar o problema). Ao contrário do exemplo anterior, esse relatório de &quot;stubs mal utilizados&quot;, se for o caso, será exibido no console (fora da saída do Junit) <strong>somente quando o teste falhar</strong>.</p>
<p>Caso prefira não utilizar a verificação de &quot;stubs não utilizados/mal utilizados&quot; (habilitado por padrão), você pode usar o Mockito no modo &quot;silencioso&quot;:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-meta">@RunWith</span>(MockitoJUnitRunner.Silent.class)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictionaryTest</span> </span>{
}
</code></pre>
<h2>Matchers do Hamcrest</h2>
<p>Uma dor de cabeça recorrente das versões 1.x do Mockito era o conflito de versões do <a href="http://hamcrest.org/JavaHamcrest/">Hamcrest</a>, uma biblioteca de <em>argument matchers</em>. Esses conflitos ocorriam porque o Mockito dependia explicitamente do Hamcrest (em função do método <a href="http://static.javadoc.io/org.mockito/mockito-core/1.10.19/org/mockito/Matchers.html#argThat(org.hamcrest.Matcher)">Matchers.argThat</a>, que aceita como parâmetro um matcher), mas as classes principais do Hamcrest são carregadas dentro do jar do JUnit (para serem utilizadas no método <a href="http://junit.org/junit4/javadoc/latest/org/junit/Assert.html#assertThat(T,%20org.hamcrest.Matcher)">Assert.assertThat</a>), o que eventualmente gerava um pequeno e clássico &quot;classpath hell&quot; (já que o Mockito dependia de uma versão e o JUnit de outra).</p>
<p>Essa dependência foi removida e o método <em>Matchers.argThat</em> (que recebia como parâmetro um matcher do Hamcrest) foi depreciado. Se quiser utilizar o Hamcrest no seu projeto, você mesmo deve incluí-lo no seu classpath de testes, e utilizar a nova classe <a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/hamcrest/MockitoHamcrest.html">MockitoHamcrest</a>.</p>
<p>A respeito da depreciação do método <em>Matchers.argThat</em>: na verdade, a classe Matchers foi inteiramente depreciada. Essa classe era extendida pela classe Mockito (a classe principal do framework), que na versão 2, passa a extender a classe <a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/ArgumentMatcher.html">ArgumentMatchers</a>.</p>
<h2>Answers.RETURNS_SELF</h2>
<p>No meu post anterior, explorei a abstração <a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/stubbing/Answer.html">Answer</a> e as várias opções possíveis para configurar a resposta dos métodos de um mock. Na versão 2, o Mockito introduziu uma nova opção chamada <a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html#RETURNS_SELF">RETURNS_SELF</a>, que é particularmente útil para testes envolvendo Builders.</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-meta">@RunWith</span>(MockitoJUnitRunner.class)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeTest</span> </span>{

    <span class="hljs-meta">@Mock</span>(answer = Answers.RETURNS_SELF)
    <span class="hljs-keyword">private</span> Builder builder;

}
</code></pre>
<p>O comportamento dessa resposta é: se algum método <strong>não configurado</strong> desse mock for invocado,</p>
<ul>
<li>Se o retorno do método for algum tipo <strong>igual à classe ou superclasse</strong> do mock, retorna a <strong>mesma instância</strong> do mock;</li>
<li>Para qualquer outro caso, seguirá o mesmo comportamento da configuração padrão do Mockito (<a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html#RETURNS_DEFAULTS">RETURNS_DEFAULTS</a>).</li>
</ul>
<p>Considere o exemplo abaixo, extraído da documentação:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpBuilder</span> </span>{

    <span class="hljs-keyword">private</span> String uri;

    <span class="hljs-keyword">private</span> List&lt;String&gt; headers;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpBuilder</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.headers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> HttpBuilder <span class="hljs-title">withUrl</span><span class="hljs-params">(String uri)</span> </span>{
        <span class="hljs-keyword">this</span>.uri = uri;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> HttpBuilder <span class="hljs-title">withHeader</span><span class="hljs-params">(String header)</span> </span>{
        <span class="hljs-keyword">this</span>.headers.add(header);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> uri + headers.toString();
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRequestWithHeaders</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpBuilder builder;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpRequestWithHeaders</span><span class="hljs-params">(HttpBuilder builder)</span> </span>{
        <span class="hljs-keyword">this</span>.builder = builder;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">request</span><span class="hljs-params">(String uri)</span> </span>{
        <span class="hljs-keyword">return</span> builder.withUrl(uri)
                .withHeader(<span class="hljs-string">"Content-type: application/json"</span>)
                .withHeader(<span class="hljs-string">"Authorization: Bearer"</span>)
                .request();
    }
}
</code></pre>
<p>E o teste:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-meta">@RunWith</span>(MockitoJUnitRunner.class)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeTest</span> </span>{

    <span class="hljs-meta">@Mock</span>(answer = Answers.RETURNS_SELF)
    <span class="hljs-keyword">private</span> HttpBuilder builder;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
          HttpRequesterWithHeaders requester = <span class="hljs-keyword">new</span> HttpRequestWithHeaders(builder);

          String response = <span class="hljs-string">"StatusCode: 200"</span>;

        <span class="hljs-comment">//permite configurar apenas o método "request" do mock, pois cada método utilizado devolve a mesma instância</span>
          when(builder.request()).thenReturn(response);

          assertThat(requester.request(<span class="hljs-string">"URI"</span>)).isEqualTo(response);
    }
}
</code></pre>
<p>O mock de Builders já era relativamente possível usando a answer <a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html#RETURNS_DEEP_STUBS">RETURNS_DEEP_STUBS</a> (que expliquei com maiores detalhes no post anterior). A principal diferença é que o RETURNS_DEEP_STUBS devolve um <strong>novo mock</strong> para cada método invocado, de modo que você precisaria navegar pela cadeia de invocações caso quisesse mockar um método específico. Com o RETURNS_SELF, isso não é necessário.</p>
<p>Como ponto de atenção, reforço o que foi explicado acima: essa answer terá efeito <strong>apenas para os métodos que devolvem o mesmo tipo da classe mockada</strong>.</p>
<h2>Spy</h2>
<p>A nova versão do Mockito traz uma mudança muito interessante sobre os <em>spies</em> (se você não os conhece, meu <a href="/testes-codigo-mockito/">post anterior</a> explica detalhadamente o que são &quot;objetos espiões&quot; e como utilizá-los). Agora, é possível &quot;espiar&quot; uma classe abstrata, o que antes não era possível. Considere o exemplo abaixo, com uma implementação do pattern <a href="https://pt.wikipedia.org/wiki/Template_Method">Template Method</a>. A idéia desse padrão é &quot;definir o esqueleto de um algoritmo, delegando alguns passos para as subclasses&quot;.</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DocumentGenerator</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> Document <span class="hljs-title">generate</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// esse método define a código-base da geração de documentos, usando os métodos implementados nas subclasses</span>
        StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();

        builder.append(header())
               .append(body())
               .append(footer());

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Document(builder.toString());
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">header</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">body</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">footer</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HtmlDocumentGenerator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DocumentGenerator</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">header</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Gera o cabeçalho do documento no formato HTML</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">body</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Gera o corpo do documento no formato HTML</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">footer</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Gera o rodapé do documento no formato HTML</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XmlDocumentGenerator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DocumentGenerator</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">header</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Gera o cabeçalho do documento no formato XML</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">body</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Gera o cabeçalho do documento no formato XML</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">footer</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Gera o cabeçalho do documento no formato XML</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}
</code></pre>
<p>Suponhamos que desejamos testar o método &quot;generate&quot; da classe DocumentGenerator, pois esee método representa a geração do documento completa (de qualquer tipo). Uma idéia válida seria usarmos um <em>partial mock</em> do DocumentGenerator, mockando os métodos auxiliares do algoritmo (no caso, &quot;header()&quot;, &quot;body()&quot; e &quot;footer()&quot;). Poderíamos utilizar o <a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Spy.html">@Spy</a> do Mockito, que nos permitir usar a implementação real do método &quot;generate&quot; e configurarmos os outros:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-meta">@RunWith</span>(MockitoJUnitRunner.class)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DocumentGeneratorTest</span> </span>{

    <span class="hljs-meta">@Spy</span>
    <span class="hljs-keyword">private</span> DocumentGenerator documentGenerator;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        doReturn(<span class="hljs-string">"[header]"</span>).when(documentGenerator).header();
        doReturn(<span class="hljs-string">"[body]"</span>).when(documentGenerator).body();
        doReturn(<span class="hljs-string">"[footer]"</span>).when(documentGenerator).footer();

        Document document = documentGenerator.generate();

        assertEquals(<span class="hljs-string">"[header][body][footer]"</span>, document.toString());
    }
}
</code></pre>
<p>No Mockito 1.x, essa configuração não vai funcionar, porque <strong>não é possível criar um spy a partir de uma classe abstrata</strong>. A &quot;solução&quot; seria criar um &quot;objeto stub&quot;, que extende DocumentGenerator, para utilizarmos no teste:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DocumentGeneratorTest</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DocumentGenerator documentGenerator = <span class="hljs-keyword">new</span> DummyDocumentGenerator();

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        Document document = documentGenerator.generate();

        assertEquals(<span class="hljs-string">"[header][body][footer]"</span>, document.toString());
    }

    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DummyDocumentGenerator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DocumentGenerator</span> </span>{

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">header</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">"[header]"</span>;
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">body</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">"[body]"</span>;
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">footer</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">"[footer]"</span>;
        }

    }
}
</code></pre>
<p>No Mockito 2.x, podemos criar um spy a partir de uma classe abstrata, e o teste inicial (exemplo anterior) rodaria sem problemas. No exemplo, a criação foi feita com a anotação @Spy; nesse caso, a única restrição é que a classe abstrata <strong>deve ter um construtor padrão (sem argumentos)</strong>. Se não for o caso, você ainda pode utilizar a <a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html#spying_abstract_classes">API programática do Mockito</a>:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeAbstractType</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String arg;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> otherArg;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SomeAbstractType</span><span class="hljs-params">(String arg, <span class="hljs-keyword">int</span> otherArg)</span> </span>{
        <span class="hljs-keyword">this</span>.arg = arg;
        <span class="hljs-keyword">this</span>.otherArg = otherArg;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeAbstractTypeTest</span> </span>{

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anyTest</span><span class="hljs-params">()</span> </span>{
        SomeAbstractType spy = mock(SomeAbstractType.class, withSettings().useConstructor(<span class="hljs-string">"arg1"</span>, <span class="hljs-number">123</span>).defaultAnswer(Answers.CALLS_REAL_METHODS));
    }
}
</code></pre>
<h2>Verificação de métodos</h2>
<p>A verificação de métodos dos mocks (realizada pelo método <a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html#verify(T)">Mockito.verify</a>) consiste em <strong>confirmar que os mocks foram invocados adequadamente</strong>, e é extremamente importante em alguns cenários de teste (em outros, nem tanto). Uma melhoria introduzida na versão 2 do Mockito é a possibilidade de verificação &quot;lazy&quot;. Abaixo, um exemplo dessa funcionalidade:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String email;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, String email)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.email = email;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEmail</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> email;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span> </span>{

    <span class="hljs-function">User <span class="hljs-title">save</span><span class="hljs-params">(User user)</span></span>;

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserEmailSender</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendTo</span><span class="hljs-params">(User user)</span></span>;

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserRepository userRepository;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserEmailSender userEmailSender;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserService</span><span class="hljs-params">(UserRepository userRepository, UserEmailSender userEmailSender)</span> </span>{
        <span class="hljs-keyword">this</span>.userRepository = userRepository;
        <span class="hljs-keyword">this</span>.userEmailSender = userEmailSender;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">persist</span><span class="hljs-params">(User user)</span> </span>{
        <span class="hljs-comment">/* aqui vamos usar o UserRepository para persistir o usuário na nossa base de dados,
         e o UserEmailSender para enviar um e-mail de boas vindas.
         Mas o código ainda não está implementado! */</span>

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}
</code></pre>
<p>Nosso teste:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-meta">@RunWith</span>(MockitoJUnitRunner.class)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceTest</span> </span>{

    <span class="hljs-meta">@Mock</span>
    <span class="hljs-keyword">private</span> UserRepository userRepository;

    <span class="hljs-meta">@Mock</span>
    <span class="hljs-keyword">private</span> UserEmailSender userEmailSender;

    <span class="hljs-meta">@InjectMocks</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shouldCreateNewUser</span><span class="hljs-params">()</span> </span>{
        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tiago de Freitas Lima"</span>, <span class="hljs-string">"tiago.lima@elo7.com"</span>);
        User newUser = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1l</span>, <span class="hljs-string">"Tiago de Freitas Lima"</span>, <span class="hljs-string">"tiago.lima@elo7.com"</span>);

        when(userRepository.save(user)).thenReturn(newUser);

        User persistedUser = userService.persist(user);

        verify(userRepository).save(user);
        verify(userEmailSender).sendTo(newUser);
    }

}
</code></pre>
<p>Implementamos nosso teste pensando no comportamento esperado do método UserService.persist; enviamos um usuário, queremos que ele seja persistido no repositório de dados e que seja enviado um email ao usuário criado. O teste irá falhar, pois o código ainda não foi implementado. E irá falhar na primeira verificação:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceTest</span> </span>{

    <span class="hljs-comment">//...código omitido</span>

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shouldCreateNewUser</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//...código omitido</span>
        verify(userRepository).save(user); <span class="hljs-comment">// falha aqui - o método do mock não foi invocado</span>
        verify(userEmailSender).sendTo(newUser); <span class="hljs-comment">// essa verificação não é executada</span>
    }
}
</code></pre>
<p>O erro no JUnit, indicando a verificação do Mockito que falhou:</p>
<pre class="highlight"><code class="hljs java">Wanted but not invoked:
userRepository.save(
    com.elo7.mockito.sample.User@<span class="hljs-number">222545</span>dc
);
-&gt; at com.elo7.mockito.sample.UserServiceTest.shouldCreateNewUser(UserServiceTest.java:<span class="hljs-number">37</span>)
Actually, there were zero interactions with <span class="hljs-keyword">this</span> mock.
</code></pre>
<p>Ao implementarmos um teste dessa forma (<a href="http://www.extremeprogramming.org/rules/testfirst.html">test-first</a>), seria útil visualizarmos todas as interações de mocks que ainda não estão implementadas no código. No exemplo acima, seria de muito valor que o Mockito nos informasse, no seu relatório de erro, que tanto o UserRepository quanto o UserEmailSender não estão sendo utilizados. No Mockito 2, isso é possível usando uma <a href="https://github.com/junit-team/junit4/wiki/rules">@Rule</a> especial chamada <a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/junit/VerificationCollector.html">VerificationCollector</a>:</p>
<pre class="highlight"><code class="hljs java"><span class="hljs-meta">@RunWith</span>(MockitoJUnitRunner.class)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceTest</span> </span>{

    <span class="hljs-meta">@Mock</span>
    <span class="hljs-keyword">private</span> UserRepository userRepository;

    <span class="hljs-meta">@Mock</span>
    <span class="hljs-keyword">private</span> UserEmailSender userEmailSender;

    <span class="hljs-meta">@InjectMocks</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-meta">@Rule</span>
    <span class="hljs-keyword">public</span> VerificationCollector collector = MockitoJUnit.collector(); <span class="hljs-comment">//basta declarar a rule</span>

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shouldCreateNewUser</span><span class="hljs-params">()</span> </span>{
        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tiago de Freitas Lima"</span>, <span class="hljs-string">"tiago.lima@elo7.com"</span>);
        User newUser = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1l</span>, <span class="hljs-string">"Tiago de Freitas Lima"</span>, <span class="hljs-string">"tiago.lima@elo7.com"</span>);

        when(userRepository.save(user)).thenReturn(newUser);

        userService.persist(user);

        verify(userRepository).save(user); <span class="hljs-comment">//essa verificação irá falhar, mas a execução do teste vai continuar</span>
        verify(userEmailSender).sendTo(newUser); <span class="hljs-comment">//essa verificação também falhará, mas novamente a execução não será interrompida</span>
    }
}
</code></pre>
<p>Agora, na saída no JUnit, o erro lançado pelo Mockito irá indicar os dois mocks não utilizados:</p>
<pre class="highlight"><code class="hljs java">org.mockito.exceptions.base.MockitoAssertionError: There were multiple verification failures:
<span class="hljs-number">1</span>. Wanted but not invoked:
userRepository.save(
    com.elo7.mockito.sample.User@<span class="hljs-number">564f</span>abc8
);
-&gt; at com.elo7.mockito.sample.UserServiceTest.shouldCreateNewUser(UserServiceTest.java:<span class="hljs-number">39</span>)
Actually, there were zero interactions with <span class="hljs-keyword">this</span> mock.
<span class="hljs-number">2</span>. Wanted but not invoked:
userEmailSender.sendTo(
    com.elo7.mockito.sample.User@<span class="hljs-number">436813f</span>3
);
-&gt; at com.elo7.mockito.sample.UserServiceTest.shouldCreateNewUser(UserServiceTest.java:<span class="hljs-number">40</span>)
Actually, there were zero interactions with <span class="hljs-keyword">this</span> mock.
</code></pre>
<p>Um detalhe importante do exemplo acima: para fins de exemplo, não inclui nenhum <em>assert</em>. Supondo que eu fizesse alguma asserção e ela falhasse (por exemplo, <em>assertNotNull</em> no retorno do método), os eventuais problemas de verificação <strong>não seriam exibidos</strong>, apenas a falha do teste. Então, os erros da verificação &quot;lazy&quot;, gerados pelo Mockito <strong>após</strong> o teste, serão exibidos apenas se não ocorrer nenhum outro problema.</p>
<h2>E mais mudanças...</h2>
<ul>
<li>
<p>A nova versão é compatível apenas com Java 6 ou superior (a versão 1.x é compatível com Java 5)</p>
</li>
<li>
<p>Os matchers <em>anyX()</em> (anyString(), anyInt(), etc) e <em>any(AlgumTipo.class)</em> passam a <strong>rejeitar valores nulos</strong>. Exemplos:</p>
</li>
</ul>
<pre class="highlight"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Translator</span> </span>{

    <span class="hljs-function">String <span class="hljs-title">translate</span><span class="hljs-params">(String word)</span></span>;

}

<span class="hljs-meta">@RunWith</span>(MockitoJUnitRunner.class)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeTest</span> </span>{

    <span class="hljs-meta">@Mock</span>
    <span class="hljs-keyword">private</span> Translator translator;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        translator.translate(<span class="hljs-keyword">null</span>);

        verify(translator).translate(anyString()); <span class="hljs-comment">// falha -&gt; null não é "qualquer String"</span>
        verify(translator).translate(any()); <span class="hljs-comment">// sucesso -&gt; null é "qualquer"</span>
    }
}
</code></pre>
<ul>
<li>
<p>O método <em>getArgumentAt</em>, da classe <a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/invocation/InvocationOnMock.html">InvocationOnMock</a> foi renomeado e teve sua assinatura alterada para inferir o tipo de retorno de forma implícita (ao invés de receber um argumento do tipo Class). Essa mudança é muito importante caso você implemente respostas customizadas. Também foram criadas novas <a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/stubbing/Answer1.html">Answers</a> para métodos com múltiplos argumentos.</p>
</li>
<li>
<p>Para fins de depuração, caso você queira visualizar todas as invocações do seu mock, você pode utilizar o novo método <a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/MockingDetails.html#printInvocations()">MockingDetails.printInvocations</a>:</p>
</li>
</ul>
<pre class="highlight"><code class="hljs java"><span class="hljs-meta">@RunWith</span>(MockitoJUnitRunner.class)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeTest</span> </span>{

    <span class="hljs-meta">@Mock</span>
    <span class="hljs-keyword">private</span> Translator translator;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        translator.translate(<span class="hljs-string">"ola"</span>);

        System.out.println(Mockito.mockingDetails(translator).printInvocations());
    }
}
</code></pre>
<p>A saída no console:</p>
<pre class="highlight"><code class="hljs java">[Mockito] Interactions of: translator
 <span class="hljs-number">1</span>. translator.translate(<span class="hljs-string">"ola"</span>);
  -&gt; at com.elo7.mockito.sample.SomeTest.test(SomeTest.java:<span class="hljs-number">17</span>)
</code></pre>
<ul>
<li>Se você está utilizando o Mockito no Android, a versão 2 traz algumas customizações de geração de bytecode específicas para a JVM do Android. Para utilizar, basta importar o artefato <em>mockito-android</em>.</li>
</ul>
<h2>Conclusão</h2>
<p>O Mockito é um dos frameworks de mocks mais utilizados na linguagem Java, muito devido à simplicidade na sua utilização e grande número de recursos. A versão 2.x manteve essa linha de implementação, além de trazer novas e interessantes funcionalidades para ajudar os desenvolvedores a escrever mais e melhores testes. Nesse post, cobri as principais mudanças e novidades da nova versão. Espero que tenha gostado! Em caso de dúvidas ou qualquer outra coisa, sinta-se à vontade para usar a caixa de comentários!</p>


		<ul class='tag-list'>
		
			<li>
				<a href='/tags/java/'>java</a>
			</li>
		
			<li>
				<a href='/tags/mockito/'>mockito</a>
			</li>
		
			<li>
				<a href='/tags/tdd/'>tdd</a>
			</li>
		
		</ul>
		<section class='share'>
			<a href='#share' class='share-post hide' title='Clique aqui para compartilhar esse post'>Compartilhe</a>
			<div class='social-share'>
				<a href='https://www.facebook.com/dialog/share?app_id=644444999041914&href=https://engenharia.elo7.com.br/testes-codigo-mockito-2/&display=popup' rel='noopener' target='_blank' class='link-share facebook' title='Clique para compartilhar no Facebook'>
					Compartilhar no facebook
				</a>
				<a href='https://twitter.com/intent/tweet?text=Testes de código com Mockito (2) - Novidades da nova versão&url=https://engenharia.elo7.com.br/testes-codigo-mockito-2/&hashtags=elo7tech' rel='noopener' target='_blank' class='link-share twitter' title='Clique para compartilhar no Twitter'>
					Compartilhar no twitter
				</a>
				<a href='https://engenharia.elo7.com.br/testes-codigo-mockito-2/?utm_source=share&utm_medium=copy' class='link-share hide copy' title='Clique para copiar a url'>
					Copiar URL
				</a>
				<span class='copy-success'>Link copiado</span>
				<input type='url' value='https://engenharia.elo7.com.br/testes-codigo-mockito-2/?utm_source=share&utm_medium=copy' class='link-input'>
			</div>
		</section>
	</div>
	<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"> <!--Change for a post image-->
		<link href="/images/ico/elo7.png" itemprop="url"/>
		<meta itemprop='width' content='100px'/>
		<meta itemprop='height' content='100px'/>
	</span>

	<meta itemprop='headline' content='Há algum tempo, escrevi sobre o funcionamento e os principais recursos do Mockito. Neste post, vamos conhecer as novidades da nova versão do framework.'/>
	<span itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
		<meta itemprop='name' content='Elo7 Tech'/>
		<meta itemprop="url" content='https://engenharia.elo7.com.br'/>
		<span itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
			<link href="https://images.elo7.com.br/assets/v3/desktop/png/logo-elo7.png" itemprop="url"/>
			<meta itemprop='width' content='100px'/>
			<meta itemprop='height' content='100px'/>
		</span>
	</span>
	<meta itemprop='mainEntityOfPage' content='Elo7 Serviços de Informática SA'/>

	<div id='disqus_thread'></div>

	<script>
		var disqus_shortname = 'engenhariaelo7';
		var disqus_identifier = '21/08/2017:/testes-codigo-mockito-2/';
		var disqus_url = 'https://engenharia.elo7.com.br/testes-codigo-mockito-2/';

		(function() {
			var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
			dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
			(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
		})();
	</script>
	<noscript>Habilite o JavaScript para ver os comentários</noscript>
</article>
<script async src="/js/post.js"></script>

		
	</main>
	<footer itemscope itemtype="http://schema.org/Organization">
		<a rel="home" itemprop="url" href="https://engenharia.elo7.com.br/" >
			engenharia.elo7.com.br © 2017
		</a>
		<meta itemprop="name" content="Elo7 Serviços de Informática SA"/>
		<section class='footer-social'>
			<a title='Github do Elo7' rel='external' itemprop='url' href='https://github.com/elo7' target='_blank' class='github'>Github do Elo7</a>
			<a title='Twitter do Elo7' rel='external' itemprop='url' href='https://twitter.com/elo7tech' target='_blank' class='twitter'>Twitter do Elo7</a>
			<a title='RSS do Elo7' rel='external' itemprop='url' href='https://engenharia.elo7.com.br/rss.xml' target='_blank' class='rss'>RSS do Elo7</a>
			<a title='Newsletter do Elo7' rel='external' itemprop='url' href='http://eepurl.com/cVUwvH' target='_blank' class='email'>Newsletter do Elo7</a>
		</section>
	</footer>
	<script async src="https://www.google-analytics.com/analytics.js"></script>
	<script async src="/js/analytics.js"></script>
	<script async src="/js/github.js"></script>
	<script async src="/js/vendor/events-amd.js"></script>
	<script async src="/js/vendor/ajax.js"></script>
	<script async src="/js/vendor/doc.js"></script>
	<script async type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
